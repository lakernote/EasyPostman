# 菜单
menu.file=文件
menu.file.log=日志
menu.file.exit=退出
menu.language=语言
menu.settings=设置
menu.help=帮助
menu.help.update=检查更新
menu.help.changelog=更新日志
menu.help.feedback=反馈
menu.about=关于
menu.about.easypostman=关于 EasyPostman
menu.collections=集合
menu.environments=环境
menu.functional=功能
menu.performance=性能
menu.history=历史
menu.workspaces=工作区
menu.toolbox=工具箱
# 工作区相关
workspace.new=新建
workspace.create=创建工作区
workspace.name=名称
workspace.default.name=默认工作区
workspace.default.description=系统默认工作区，不可删除和重命名
workspace.description=描述
workspace.type=类型
workspace.type.local=本地工作区
workspace.type.git=Git 工作区
workspace.path=路径
workspace.select.path=选择路径
workspace.git.url=Git 仓库地址
workspace.git.username=用户名
workspace.git.password=密码
workspace.git.token=访问令牌
workspace.git.auth.type=认证方式
workspace.git.auth.none=无认证
workspace.git.auth.password=用户名密码
workspace.git.auth.token=访问令牌
workspace.git.auth.ssh=SSH 密钥
# SSH 认证相关
workspace.git.ssh.private_key=SSH 私钥文件
workspace.git.ssh.select_key=选择私钥文件
workspace.git.ssh.passphrase=私钥密码（可选）
workspace.clone.from.remote=从远程仓库克隆
workspace.init.local=本地初始化
workspace.rename=重命名
workspace.delete=删除
workspace.delete.confirm=确定删除工作区 "{0}" 吗？
workspace.switch=切换工作区
workspace.info=工作区信息
workspace.git.pull=拉取更新
workspace.git.push=推送变更
workspace.git.commit=提交变更
workspace.git.auth.update=更新认证
workspace.git.auth.update.success=Git 认证信息已成功更新
workspace.git.auth.update.failed=更新 Git 认证信息失败：{0}
workspace.validation.name.required=请输入工作区名称
workspace.validation.path.required=请选择本地路径
workspace.validation.git.url.required=请输入 Git 仓库地址
workspace.validation.git.branch.invalid=请输入分支名称
workspace.validation.auth.required=请输入认证信息
workspace.auto_generate_path=根据名称自动生成路径
# 工作区详情面板
workspace.detail.basic_info=基本信息
workspace.detail.created_time=创建时间
workspace.detail.git_info=Git 信息
workspace.detail.repo_source=仓库来源
workspace.detail.remote_repo=远程仓库
workspace.detail.local_branch=本地分支
workspace.detail.remote_branch=远程分支
workspace.detail.last_commit=最后提交
# 语言
language.changed=语言切换成功。部分界面元素可能需要重启才能完全更新。
# 更新相关
update.new_version_found=发现新版本：{0}\n请选择升级方式：
update.new_version_available=发现新版本
update.later=稍后
update.now=立即更新
update.view_details=查看详情
update.manual_download=手动下载
update.auto_download=自动下载并安装
update.cancel=取消
update.downloading=自动下载并安装
update.connecting=正在连接服务器...
update.download_progress=下载进度：{0} / {1}
update.download_speed=下载速度：{0}
update.estimated_time=预估时间：{0}
update.cancel_download=取消下载
update.download_cancelled=下载已取消
update.download_failed=下载失败：{0}
update.install_prompt=安装包已下载，是否立即打开安装？\n请确保已关闭所有 EasyPostman 程序，否则安装可能失败。\n点击"是"将自动关闭本程序并打开安装包。
update.open_installer_failed=打开安装包失败：{0}
update.no_installer_found=未找到最新安装包（.msi/.dmg）下载链接。
# 版本检查器相关
update.fetch_release_failed=获取版本信息失败
update.no_version_info=未找到版本信息
update.already_latest=已经是最新版本 {0}
# 更新日志相关
changelog.title=版本更新日志
changelog.current_version=当前版本：{0}
changelog.loading=正在加载更新日志...
changelog.load_failed=加载更新日志失败：{0}
changelog.no_releases=暂无版本发布记录
changelog.view_on_github=在 GitHub 上查看
changelog.view_on_gitee=在 Gitee 上查看
changelog.close=关闭
changelog.refresh=刷新
# 错误信息
error.update_failed=检查更新失败：{0}
error.open_log_message=打开日志目录失败。请检查日志。
error.open_link_failed=打开链接失败：{0}
error.network_timeout=网络连接超时，请检查网络后重试。
error.server_unreachable=无法连接服务器，请检查网络。
error.invalid_download_link=下载链接无效或文件不存在。
error.disk_space_insufficient=磁盘空间不足，请清理后重试。
error.permission_denied=没有写入权限，请检查文件夹权限。
error.io_exception=下载文件时发生IO异常：{0}
# 关于对话框
about.version=版本：{0}
about.author=作者：lakernote
about.license=协议：Apache-2.0
about.wechat=微信：lakernote
about.blog=博客：https://laker.blog.csdn.net
about.github=GitHub：https://github.com/lakernote
about.gitee=Gitee：https://gitee.com/lakernote
# 反馈
feedback.message=请通过 Gitee 或 GitHub 提交问题。
feedback.title=反馈
# 通用
general.error=错误
general.info=信息
general.tip=提示
general.ok=确定
console.title=控制台
sidebar.toggle=展开/收起侧边栏
# Buttons
button.send=发送
button.save=保存
button.save.tooltip=保存当前请求
button.cancel=取消
button.close=关闭
button.start=开始
button.stop=停止
button.search=搜索...
button.connect=连接
button.calculate=计算
new.request=未命名
create.new.request=创建新请求
save.request=保存请求
request.name=请求名称
request.url.placeholder=请输入请求URL
select.group=选择分组
please.enter.request.name=请输入请求名称
please.select.group=请选择分组
please.select.valid.group=请选择有效的分组节点
success=成功
update.request.failed=更新请求失败
error=错误
clipboard.curl.detected=检测到剪贴板有 cURL 命令，是否导入到新请求？
import.curl=导入cURL
parse.curl.error=解析cURL出错: {0}
tip=提示
tab.params=参数
tab.authorization=授权
tab.scripts=脚本
tab.cookies=Cookie
tab.tests=测试结果
tab.network_log=网络日志
tab.request_headers=请求头
tab.request_body=请求体
tab.response_headers=响应头
tab.response_body=响应体
status.canceled=状态：已取消
status.requesting=状态：请求中...
status.duration=耗时：%s
status.response_size=大小：--
status.prefix=状态：{0}
websocket.failed=WebSocket连接失败: {0}
websocket.error=WebSocket发生错误: {0}
websocket.not_connected=WebSocket未连接，请先建立连接。
sse.failed=SSE连接失败: {0}
sse.error=SSE发生错误: {0}
script.tab.prescript=前置脚本
script.tab.postscript=后置脚本
script.tab.help=帮助
script.button.snippets=代码片段
script.help.text=PreScript/PostScript 可用变量：\nrequest, env, postman/pm, responseBody, responseHeaders, status, statusCode 等。\n可在脚本中通过 pm.environment.set('key', 'value') 设置环境变量。\n详细用法请参考文档或悬停提示。\n\n【Tab 补全说明】\n- 输入 pm. 后按 Tab 可快速补全 pm 相关方法，如 pm.environment.set。\n- 输入 console.log 后按 Tab 可快速插入日志代码片段。\n- 输入 JSON.parse(responseBody) 后按 Tab 可快速插入解析响应体的代码。\n- 还支持 if、for、function 等常用 JS 语句的补全。\n- 鼠标悬停在补全项上可查看详细说明。\n\n示例：\npm.environment.set('token', '123');\nconsole.log('调试信息');\nvar obj = JSON.parse(responseBody);\nif (statusCode === 200) {\n    // 处理成功\n}\n
auth.type.label=认证类型：
auth.type.none.desc=此请求不使用任何认证。
auth.username=用户名：
auth.password=密码：
auth.token=令牌：
cookies.title=Cookies
cookies.manager_title=Cookie 管理器
cookie.button.delete=删除
cookie.button.clear=清空全部
cookie.button.add=添加
cookie.button.edit=编辑
cookie.button.refresh=刷新
cookie.tooltip.add=添加新Cookie
cookie.tooltip.edit=编辑选中的Cookie
cookie.tooltip.delete=删除选中Cookie
cookie.tooltip.clear=清空所有Cookie
cookie.tooltip.refresh=刷新Cookie列表
cookie.dialog.clear_confirm=确定要清空所有Cookie吗？
cookie.dialog.clear_confirm_title=确认
cookie.dialog.add_title=添加Cookie
cookie.dialog.edit_title=编辑Cookie
cookie.dialog.error.empty=名称和域名不能为空
cookie.dialog.error.title=错误
cookie.delete_confirm=确定要删除Cookie "%s" (域名: %s) 吗？
cookie.delete_confirm_title=确认删除
cookie.error_no_selection=请先选择一个Cookie
cookie.search_placeholder=搜索Cookie (名称/值/域名)
cookie.empty_state=暂无Cookie
cookie.empty_state_hint=发送请求后，服务器返回的Cookie将自动显示在这里
cookie.edit_hint=注意：编辑时不能修改名称、域名和路径
cookie.column.name=名称
cookie.column.value=值
cookie.column.domain=域名
cookie.column.path=路径
cookie.column.expires=过期时间
cookie.column.secure=Secure
cookie.column.httponly=HttpOnly
cookie.field.name=名称
cookie.field.value=值
cookie.field.domain=域名
cookie.field.path=路径
cookie.field.secure=Secure (仅HTTPS)
cookie.field.httponly=HttpOnly (禁止JS访问)
env.button.add=新增环境
env.button.rename=重命名
env.button.duplicate=复制
env.button.delete=删除
env.button.export_postman=导出为Postman
env.menu.import_easy=从EasyPostman导入
env.menu.import_postman=从Postman导入
env.dialog.save_changes=存在环境变量修改，是否保存？
env.dialog.save_changes.title=提示
env.dialog.export.title=导出环境变量
env.dialog.export.success=导出成功！
env.dialog.export.fail=导出失败: {0}
env.dialog.import_easy.title=导入EasyPostman环境变量
env.dialog.import_easy.success=导入成功！
env.dialog.import_easy.fail=导入失败: {0}
env.dialog.import_postman.title=导入Postman环境变量
env.dialog.import_postman.fail=导入失败: {0}
env.dialog.import_postman.invalid=未解析到有效环境
env.dialog.add.title=新增环境
env.dialog.add.prompt=请输入环境名称:
env.dialog.rename.title=重命名环境
env.dialog.rename.prompt=请输入新的环境名称:
env.dialog.rename.fail=环境名称不能为空或未更改
env.dialog.delete.title=删除环境
env.dialog.delete.prompt=确定要删除环境 "{0}" 吗?\n此操作不可恢复。
env.dialog.copy.fail=复制失败: {0}
env.name.copy_suffix=副本
env.dialog.export_postman.title=导出为Postman环境
env.dialog.export_postman.success=成功导出为Postman环境！
env.dialog.export_postman.fail=导出为Postman环境失败: {0}
# 环境转移到其他工作区相关
env.menu.move_to_workspace=转移到其他工作区
env.menu.move_to_workspace.select=选择目标工作区
env.menu.move_to_workspace.success=环境已成功转移到工作区：{0}
env.menu.move_to_workspace.fail=转移环境失败：{0}
env.menu.move_to_workspace.confirm=确定将环境 "{0}" 转移到工作区 "{1}" 吗？
env.menu.move_to_workspace.confirm_title=确认转移环境
# 功能测试相关
functional.tab.request_config=请求配置
functional.tab.execution_results=执行结果
button.load=加载
button.clear=清空
button.refresh=刷新
functional.msg.no_runnable_request=没有可运行的请求
functional.msg.csv_detected=检测到 CSV 数据文件，包含 {0} 行数据。\n是否使用 CSV 数据进行数据驱动测试？\n选择'是'将为每行数据执行一次所有选中的请求。
functional.msg.csv_title=CSV 数据驱动测试
functional.status.not_executed=未执行
functional.status.pre_script_failed=前置脚本失败
functional.status.sse_batch_not_supported=SSE请求，无法批量执行
functional.status.ws_batch_not_supported=WebSocket请求，无法批量执行
# 性能测试相关
performance.tab.trend=趋势
performance.tab.report=报表
performance.tab.result_tree=结果树
performance.tab.request=请求
performance.tab.response=响应
performance.tab.tests=断言
performance.tab.timing=耗时
performance.tab.event_info=事件
performance.no_assertion_results=<html><body><i>无断言结果</i></body></html>
performance.no_timing_info=<html><body><i>无耗时信息</i></body></html>
performance.no_event_info=<html><body><i>无事件信息</i></body></html>
performance.property.select_node=请在左侧选择节点进行编辑
performance.efficient_mode=高效模式
performance.efficient_mode.tooltip=只记录错误结果以减少内存占用
performance.efficient_mode.help=高效模式说明
performance.efficient_mode.desc=高效模式：\n只记录断言失败或请求异常的结果，极大减少内存占用。适合高并发/大循环压测。可扩展更多性能相关配置。
performance.efficient_mode.help_title=高效模式说明
performance.progress.tooltip=活跃线程数 / 总线程数
performance.menu.add_thread_group=添加用户组
performance.menu.add_request=添加请求
performance.menu.add_assertion=添加断言
performance.menu.add_timer=添加定时器
performance.menu.rename=重命名
performance.menu.delete=删除
performance.msg.select_thread_group=请选择线程组节点进行添加
performance.msg.rename_node=重命名节点：
performance.msg.execution_interrupted=执行被中断: {0}
performance.msg.execution_completed=执行完成！总请求数: {0}, 成功: {1}, 耗时: {2}秒
performance.msg.pre_script_failed=前置脚本执行失败: {0}
performance.msg.request_failed=请求执行失败: {0}
performance.msg.assertion_failed=断言失败: {0} - {1}
performance.trend.threads=线程数
performance.trend.response_time_ms=响应时间 (毫秒)
performance.trend.response_time=响应时间
performance.trend.qps=QPS
performance.trend.error_rate_percent=错误率 (%)
performance.trend.error_rate=错误率
performance.trend.chart_title=API 性能趋势
performance.trend.time=时间
performance.trend.metric_value=指标值
performance.trend.metrics=指标：
performance.trend.no_metric_selected=未选择指标
performance.test_plan=测试计划
performance.thread_group=用户组
performance.default_request=百度首页
# 历史面板
history.empty_body=<html><body>请选择一条记录。</body></html>
history.today=今天
history.yesterday=昨天
# Tab标签页
tab.request=请求
tab.response=响应
tab.timing=时间线
tab.events=事件
app.name=EasyPostman
splash.status.starting=正在启动 EasyPostman...
splash.status.loading_main=正在加载主窗口...
splash.status.initializing=正在初始化组件...
splash.status.ready=准备就绪
splash.status.done=完成，正在显示主窗口...
splash.error.load_main=主窗口加载失败，请重启应用程序。
exit.unsaved_changes=存在未保存的更改，是否全部保存？
exit.unsaved_changes.title=未保存的更改
exit.save_all=全部保存
exit.discard_all=全部不保存
exit.cancel=取消
collections.export.tooltip=导出请求集合
collections.import.tooltip=导入请求集合
collections.import.curl.detected=检测到剪贴板有 cURL 命令，是否导入？
collections.import.curl.title=导入cURL
collections.import.easy=从EasyPostman导入
collections.import.postman=从Postman v2.1导入
collections.import.curl=从cURL导入
collections.menu.add_group=新增分组
collections.menu.add_root_group=新增Root分组
collections.menu.add_request=新增请求
collections.menu.duplicate=复制选项
collections.menu.export_postman=导出为Postman v2.1
collections.menu.copy_curl=复制为cURL
collections.menu.rename=重命名
collections.menu.delete=删除
collections.menu.copy_suffix=副本
collections.menu.copy_curl.success=cURL命令已复制到剪贴板！
collections.menu.copy_curl.fail=生成cURL命令失败: {0}
collections.menu.export_postman.select_group=请选择分组节点导出
collections.menu.export_postman.dialog_title=导出为Postman集合
collections.menu.move_to_workspace=转移到其他工作区
collections.menu.move_to_workspace.select=选择目标工作区
collections.menu.move_to_workspace.fail=转移集合失败：{0}
collections.menu.move_to_workspace.confirm=确定将集合 "{0}" 转移到工作区 "{1}" 吗？
collections.menu.move_to_workspace.confirm_title=确认转移集合
collections.export.dialog_title=导出请求集合
collections.export.success=导出成功！
collections.export.fail=导出失败: {0}
collections.import.dialog_title=导入请求集合
collections.import.success=导入成功！
collections.import.fail=导入失败: {0}
collections.import.postman.dialog_title=从Postman导入
collections.import.postman.invalid=不是有效的Postman集合文件
collections.import.curl.dialog_title=从cURL导入
collections.import.curl.dialog_prompt=请输入cURL命令:
collections.import.curl.parse_fail=无法解析cURL命令
collections.import.curl.parse_error=解析cURL出错: {0}
collections.dialog.add_group.prompt=请输入集合名称:
collections.dialog.add_request.title=新增请求
collections.dialog.add_request.name=请求名称:
collections.dialog.add_request.protocol=协议类型:
collections.dialog.add_request.name_empty=请求名称不能为空！
collections.dialog.rename_group.prompt=输入新的组名：
collections.dialog.rename_group.title=重命名集合
collections.dialog.rename_group.empty=组名不能为空！
collections.dialog.rename_request.prompt=输入新的请求名：
collections.dialog.rename_request.title=重命名请求
collections.dialog.rename_request.empty=请求名不能为空！
collections.dialog.multi_select.title=多选请求
collections.dialog.multi_select.empty=请至少选择一个请求
collections.delete.confirm=确定要删除所选项吗？
collections.delete.batch_confirm=确定要删除所选的 {0} 项吗？
collections.delete.confirm_title=删除确认
general.error.message=发生未知错误，请查看日志文件获取详细信息。
# 功能测试执行结果相关
functional.execution.results=执行结果
functional.execution.history=执行历史
functional.execution.results.no_data=暂无执行数据
functional.execution.results.summary={0} 轮迭代，总耗时 {1}
functional.button.expand_all=全部展开
functional.button.collapse_all=全部收起
functional.tooltip.expand_all=展开所有节点
functional.tooltip.collapse_all=收起所有节点
functional.tooltip.refresh=刷新数据
functional.detail.info=详细信息
functional.tab.overview=概览
functional.status.ready=就绪
functional.status.updating=正在更新数据...
functional.status.updated=数据更新完成
functional.status.refreshing=正在刷新...
functional.status.refreshed=刷新完成
functional.status.iteration_selected=已选择迭代
functional.status.request_selected=已选择请求
functional.status.overview_selected=已选择概览
# 功能测试详情页面相关
functional.detail.overview=执行概览
functional.detail.iteration=迭代详情
functional.detail.execution_stats=执行统计
functional.detail.iteration_info=迭代信息
functional.detail.csv_data=CSV 数据
functional.detail.welcome_message=选择左侧的记录查看详细信息
functional.detail.welcome_subtitle=支持查看请求、响应、测试结果等
# 功能测试统计相关
functional.stats.total_iterations=总迭代数
functional.stats.total_requests=总请求数
functional.stats.total_time=总耗时
functional.stats.success_rate=成功率
functional.stats.start_time=开始时间
functional.stats.end_time=结束时间
functional.stats.average_time=平均耗时
functional.stats.status=状态
functional.stats.status_completed=已完成
# 功能测试表格相关
functional.table.iteration=迭代
functional.table.request_name=请求名称
functional.table.method=方法
functional.table.status=状态
functional.table.time=耗时
functional.table.assertion=断言
functional.table.timestamp=时间戳
# 功能测试迭代相关
functional.iteration.round=迭代轮次
functional.iteration.round.format=第 {0} 轮
functional.iteration.round.prefix=第
functional.iteration.round.suffix=轮
functional.iteration.start_time=开始时间
functional.iteration.execution_time=执行时长
functional.iteration.request_count=请求数量
functional.iteration.passed_format=第 {0} 轮 ({1}/{2} 通过, {3})
# ============ 线程组相关 ============
# 线程组模式
threadgroup.mode.fixed=固定线程数
threadgroup.mode.ramp_up=递增线程数
threadgroup.mode.spike=尖刺线程
threadgroup.mode.stairs=阶梯线程
# 线程组界面标签
threadgroup.mode.label=线程模式:
threadgroup.preview.title=负载模式预览
# 固定模式标签
threadgroup.fixed.users=用户数:
threadgroup.fixed.execution_mode=执行方式:
threadgroup.fixed.use_time=按时间
threadgroup.fixed.loops=循环次数:
threadgroup.fixed.duration=持续时间(秒):
# 递增模式标签
threadgroup.rampup.start_users=起始用户数:
threadgroup.rampup.end_users=最终用户数:
threadgroup.rampup.ramp_time=递增时间(秒):
threadgroup.rampup.test_duration=测试持续(秒):
# 尖刺模式标签
threadgroup.spike.min_users=最小用户数:
threadgroup.spike.max_users=最大用户数:
threadgroup.spike.ramp_up_time=上升时间(秒):
threadgroup.spike.hold_time=保持时间(秒):
threadgroup.spike.ramp_down_time=下降时间(秒):
threadgroup.spike.test_duration=测试持续(秒):
# 阶梯模式标签
threadgroup.stairs.start_users=起始用户数:
threadgroup.stairs.end_users=最终用户数:
threadgroup.stairs.step_size=阶梯步长:
threadgroup.stairs.hold_time=阶梯保持(秒):
threadgroup.stairs.test_duration=测试持续(秒):
# 预览面板标签
threadgroup.preview.time_seconds=时间 (秒)
threadgroup.preview.mode_prefix=模式:
# ============ 设置对话框相关 ============
# 对话框标题和标签
settings.dialog.save=保存
settings.dialog.cancel=取消
# 请求设置部分
settings.request.title=请求设置
settings.request.max_body_size=响应体最大显示大小 (KB):
settings.request.max_body_size.tooltip=响应体内容最大显示多少 KB，超出将被截断
settings.request.timeout=请求超时时间 (ms, 0=永不超时):
settings.request.timeout.tooltip=接口请求超时时间，0 表示不限制
settings.request.max_download_size=最大响应下载大小 (MB, 0=不限制):
settings.request.max_download_size.tooltip=下载响应体最大允许大小，0 表示不限制
settings.request.follow_redirects=自动重定向 (Follow Redirects):
settings.request.follow_redirects.tooltip=请求遇到重定向时是否自动跟随跳转
settings.request.follow_redirects.checkbox=自动重定向
settings.request.ssl_verification=SSL 证书验证 (SSL Certificate Verification):
settings.request.ssl_verification.tooltip=是否验证 HTTPS 请求的 SSL 证书（禁用后可能存在安全风险）
settings.request.ssl_verification.checkbox=禁用
# JMeter设置部分
settings.jmeter.title=压测连接设置
settings.jmeter.max_idle=最大空闲连接数:
settings.jmeter.max_idle.tooltip=线程池最大空闲连接数
settings.jmeter.keep_alive=连接保活时间 (秒):
settings.jmeter.keep_alive.tooltip=连接最大保活时间，单位秒
# 下载设置部分
settings.download.title=下载设置
settings.download.show_progress=下载大文件时显示进度弹窗
settings.download.show_progress.tooltip=下载大文件时弹出进度提示窗口
settings.download.threshold=进度弹窗阈值 (MB):
settings.download.threshold.tooltip=下载文件大于此阈值时弹窗
# 通用设置部分
settings.general.title=通用设置
settings.general.max_history=最大历史记录数量:
settings.general.max_history.tooltip=保存的最大历史记录条数
settings.general.max_opened_requests=最大打开请求数:
settings.general.max_opened_requests.tooltip=最多同时保存的未关闭请求标签数量，超出后将自动移除最早的请求。
settings.general.auto_format_response=根据响应类型自动格式化
settings.general.auto_format_response.tooltip=自动格式化 JSON 和 XML 响应体，使其更易读
settings.general.sidebar_expanded=默认展开侧边栏
settings.general.sidebar_expanded.tooltip=启动时侧边栏是否展开显示完整标签
# 设置验证
settings.validation.error.title=验证错误
settings.validation.max_body_size.error=响应体大小不能小于0
settings.validation.timeout.error=超时时间不能小于0
settings.validation.max_download_size.error=下载大小不能小于0
settings.validation.max_idle.error=最大连接数必须大于0
settings.validation.keep_alive.error=连接保活时间必须大于0
settings.validation.threshold.error=进度弹窗阈值不能小于0
settings.validation.max_history.error=历史记录数量必须大于0
settings.validation.max_opened_requests_error=最大打开请求数必须为大于0的整数。
settings.validation.invalid_number=请输入有效的数字
# 成功消息
settings.save.success=设置已保存
settings.save.success.title=成功
settings.sidebar.restart.required=侧边栏展开设置将在下次启动时生效
tab.close_others=关闭其他
tab.close_all=关闭全部
tab.unsaved_changes.save_current=当前标签有未保存的更改，是否保存后关闭？
tab.unsaved_changes.save_others=其他标签有未保存的更改，是否保存后关闭？
tab.unsaved_changes.save_all=有标签存在未保存的更改，是否全部保存后关闭？
tab.unsaved_changes.title=未保存的更改
tab.close_current=关闭当前
request.body.type=类型：
request.body.format=格式：
request.body.none=该请求无Body
request.body.format.only_raw=仅Raw类型Body可格式化
request.body.format.empty=Body为空，无法格式化
response.headers.copy_selected=复制选中
response.headers.copy_cell=复制单元格
response.headers.copy_all=复制全部
response.headers.select_all=全选
# ============ CSV 数据面板相关 ============
csv.status.no_data=未加载 CSV 数据
csv.status.loaded=CSV: {0} ({1} 行数据)
csv.manual_created=手动创建
csv.button.clear.tooltip=清除 CSV 数据
csv.menu.import_file=导入 CSV 文件
csv.menu.manage_data=管理 CSV 数据
csv.menu.clear_data=清除 CSV 数据
csv.data.cleared=CSV 数据已清除
csv.dialog.management.title=CSV数据管理
csv.data_driven_test=CSV数据驱动测试
csv.dialog.description=CSV 数据驱动测试允许您使用外部数据文件为每行数据执行一次测试。\n• CSV 文件第一行应为列标题\n• 支持两种使用方式：\n  1. 在请求URL、Header、Body中直接使用 {{列名}} 占位符\n  2. 在脚本中使用 pm.variables.get('列名') 访问数据\n• 支持的编码：UTF-8
csv.current_status=当前状态
csv.operations=操作
csv.button.select_file=选择 CSV 文件
csv.button.manage_data=管理数据
csv.button.clear_data=清除数据
csv.no_manageable_data=没有可管理的 CSV 数据
csv.data_management=CSV数据管理
csv.data_source_info=<html>数据来源: <b>{0}</b> | 行数: <b>{1}</b></html>
csv.button.add_row=添加行
csv.button.delete_row=删除行
csv.button.add_column=添加列
csv.button.delete_column=删除列
csv.select_rows_to_delete=请先选择要删除的行
csv.confirm_delete_rows=确定要删除选中的 {0} 行数据吗？
csv.confirm_delete=确认删除
csv.enter_column_name=请输入新列名:
csv.add_column=添加列
csv.select_columns_to_delete=请先选择要删除的列
csv.cannot_delete_all_columns=不能删除所有列，至少需要保留一列
csv.confirm_delete_columns=确定要删除选中的列吗？\n列名: {0}
csv.usage_instructions=使用说明
csv.usage_text=• 双击单元格可直接编辑内容\n• 支持两种使用方式：{{列名}} 占位符 或 pm.variables.get('列名')\n• 例如：URL中使用 {{baseUrl}}/users 或脚本中使用 pm.variables.get('userId')
csv.no_valid_data_rows=没有有效的数据行，请至少添加一行数据
csv.data_saved=数据已保存！共 {0} 行数据，{1} 列
csv.save_success=保存成功
csv.save_failed=保存数据失败: {0}
csv.select_file=选择 CSV 文件
csv.file_filter=CSV 文件 (*.csv)
csv.file_validation_failed=文件验证失败
csv.no_valid_data=CSV 文件没有有效数据
csv.load_failed=读取 CSV 文件失败: {0}
csv.file_not_exist=文件不存在
csv.file_not_valid=不是有效的文件
csv.file_not_csv=不是 CSV 文件
download.progress.title=下载进度
download.cancelled=下载已取消
binary.too.large=二进制内容大小 {0}MB 超出最大下载限制（{1} MB）
binary.too.large.body=[二进制内容超出最大下载限制，未下载。限制：{0} MB]
binary.saved_temp_file=[二进制内容，已保存为临时文件]
no.response.body=[无响应体]
download.limit.title=下载限制
text.too_large=文本内容大小 {0}MB 超出最大下载限制（{1} MB）
text.too_large.body=[文本内容超出最大下载限制，未下载。限制：{0} MB]
body.too_large.saved=[响应体内容超过{0}KB，已保存为临时文件，可下载查看完整内容]
sse.stream.unsupported=[SSE 流响应，无法直接处理]
# ResponseAssertion 国际化
response.assertion.status_failed=响应状态码断言失败: 期望={0}, 实际={1}
response.assertion.header_not_found=响应头不存在
response.assertion.header_not_found_with_name=响应头不存在: {0}
response.assertion.below_failed=响应耗时断言失败: 期望小于{0}, 实际={1}
response.assertion.invalid_json=响应体不是有效的JSON: {0}
# Expectation 国际化
expectation.include_failed=include断言失败: 期望包含={0}, 实际={1}
expectation.eql_failed=eql断言失败: 期望={0}, 实际={1}
expectation.property_not_found=property断言失败: 不存在属性={0}
expectation.property_not_map=property断言失败: actual不是Map类型
expectation.match_regex_failed=match断言失败: 正则={0}, 实际={1}
expectation.match_pattern_failed=match断言失败: pattern={0}, 实际={1}
expectation.match_jsregexp_failed=match断言失败: 非法JavaScript正则对象={0}, 实际={1}
expectation.below_failed=below断言失败: 期望小于={0}, 实际={1}
autocomplete.pm=Postman pm 对象，常用断言/环境操作
autocomplete.postman=Postman 旧版对象
autocomplete.request=请求对象
autocomplete.response=响应对象
autocomplete.env=环境变量对象
autocomplete.response_body=响应体字符串
autocomplete.response_headers=响应头对象
autocomplete.status=响应状态
autocomplete.status_code=响应状态码
autocomplete.set_env=设置环境变量
autocomplete.get_env=获取环境变量
autocomplete.if=条件语句
autocomplete.else=条件语句
autocomplete.for=循环语句
autocomplete.while=循环语句
autocomplete.function=函数定义
autocomplete.return=返回语句
autocomplete.snippet.set_env=设置环境变量
autocomplete.snippet.get_env=获取环境变量
autocomplete.snippet.btoa=将字符串转换为 Base64 编码
autocomplete.snippet.atob=将 Base64 编码转换为字符串
autocomplete.snippet.encode_uri=对字符串进行 URL 编码
autocomplete.snippet.decode_uri=对 URL 编码的字符串进行解码
autocomplete.snippet.console_log=打印日志
autocomplete.snippet.json_parse=解析响应体为 JSON 对象
autocomplete.snippet.json_stringify=将对象转换为 JSON 字符串
workspace.remote.config.title=远程仓库配置
workspace.config.progress=配置进度
workspace.config.progress.start=正在配置远程仓库...
workspace.config.progress.validating=正在验证远程仓库配置...
workspace.config.progress.done=远程仓库配置完成！
workspace.config.progress.failed=配置远程仓库失败: {0}
workspace.validation.git.url.invalid=请输入有效的 Git 仓库 URL
# 自动更新设置
settings.auto_update.title=自动更新设置
settings.auto_update.enabled=启用自动检查更新:
settings.auto_update.enabled.tooltip=启用后将定期检查软件更新
settings.auto_update.enabled.checkbox=自动检查更新
settings.auto_update.interval=检查间隔(小时):
settings.auto_update.interval.tooltip=自动检查更新的时间间隔，单位为小时
settings.auto_update.startup_delay=启动延迟(秒):
settings.auto_update.startup_delay.tooltip=应用启动后多少秒开始检查更新
settings.update_source.preference=更新源:
settings.update_source.preference.tooltip=选择检查更新和下载的来源（自动选择、GitHub 或 Gitee）
settings.update_source.auto=自动选择（推荐）
settings.update_source.github=GitHub（国外用户/VPN）
settings.update_source.gitee=Gitee（国内用户）
settings.validation.auto_update_interval.error=请输入有效的更新检查间隔时间（大于0的整数）
settings.validation.auto_update_startup_delay.error=请输入有效的启动延迟时间（大于等于0的整数）
settings.ui.title=界面设置
websocket.panel.label.send_message=消息
websocket.panel.checkbox.clear=发送后清空输入
websocket.panel.label.timeout=间隔 (毫秒):
websocket.panel.button.start=启动定时器
websocket.panel.button.stop=停止定时器
websocket.panel.button.send=发送
# WebSocket Response Panel
websocket.column.type=类型
websocket.column.time=时间
websocket.column.content=内容
websocket.type.all=全部
websocket.type.sent=发送
websocket.type.received=接收
websocket.type.connected=连接
websocket.type.closed=断开
websocket.type.warning=警告
websocket.type.info=信息
websocket.type.binary=二进制
button.clear_messages=清除
button.copy=复制
button.detail=详情
button.format=格式化
button.raw=原始
websocket.dialog.title=消息内容
plus.panel.hint=点击此处或使用快捷键创建新请求
exit.shortcut.desc=退出快捷键：Ctrl+Q（Mac 下为 Cmd+Q）
plus.panel.shortcut.desc=新建请求快捷键：Ctrl+N（Mac 下为 Cmd+N）
save.shortcut.desc=保存快捷键：Ctrl+S（Mac 下为 Cmd+S）
# --- Snippet 国际化 ---
snippet.setRequestVariable.title=前置-设置请求变量
snippet.setRequestVariable.desc=设置请求级别的变量，仅在当前请求中有效
snippet.setLocalVariable.title=前置-设置局部变量
snippet.setLocalVariable.desc=设置仅在当前请求中有效的局部变量
snippet.randomUUID.title=前置-随机UUID
snippet.randomUUID.desc=生成随机UUID并保存到环境变量
snippet.dynamicTimestamp.title=前置-动态时间戳
snippet.dynamicTimestamp.desc=生成当前时间戳并保存到环境变量
snippet.signature.title=前置-签名计算
snippet.signature.desc=计算API签名并保存到环境变量
snippet.dynamicParam.title=前置-动态参数处理
snippet.dynamicParam.desc=生成格式化的当前日期并保存到环境变量
snippet.jwtParse.title=前置-JWT解析
snippet.jwtParse.desc=解析JWT令牌并提取有用信息
snippet.encryptRequestData.title=前置-请求数据加密
snippet.encryptRequestData.desc=加密请求数据中的敏感字段
snippet.dynamicHeader.title=前置-动态请求头
snippet.dynamicHeader.desc=生成动态请求头参数并保存到环境变量
snippet.conditional.title=前置-条件判断
snippet.conditional.desc=根据条件动态设置不同的环境参数
snippet.dynamicModifyHeader.title=前置-动态修改请求头
snippet.dynamicModifyHeader.desc=动态添加和修改请求头信息
snippet.dynamicModifyBody.title=前置-动态修改请求体
snippet.dynamicModifyBody.desc=动态修改请求体和所有参数（formData、urlencoded、formFiles）
snippet.dynamicModifyParam.title=前置-动态修改请求参数
snippet.dynamicModifyParam.desc=为请求URL和参数动态添加签名、时间戳等字段
snippet.assertStatus200.title=断言-状态码为200
snippet.assertStatus200.desc=断言响应状态码为200
snippet.assertBodyContains.title=断言-Body包含字符串
snippet.assertBodyContains.desc=断言响应体包含指定字符串
snippet.assertJsonValue.title=断言-JSON属性值
snippet.assertJsonValue.desc=断言JSON属性值等于0
snippet.assertHeaderPresent.title=断言-Header存在
snippet.assertHeaderPresent.desc=断言响应头存在
snippet.assertResponseTime.title=断言-响应时间<1000ms
snippet.assertResponseTime.desc=断言响应时间小于1000ms
snippet.assertFieldExists.title=断言-字段存在
snippet.assertFieldExists.desc=断言JSON中存在data字段
snippet.assertArrayLength.title=断言-数组长度
snippet.assertArrayLength.desc=断言数组长度为3
snippet.assertRegex.title=断言-正则匹配
snippet.assertRegex.desc=断言响应体正则匹配
snippet.extractJsonToEnv.title=提取-JSON字段到环境变量
snippet.extractJsonToEnv.desc=提取token到环境变量
snippet.extractHeaderToEnv.title=提取-Header到环境变量
snippet.extractHeaderToEnv.desc=提取响应头X-Token到环境变量
snippet.extractRegexToEnv.title=提取-正则匹配到环境变量
snippet.extractRegexToEnv.desc=使用正则提取token到环境变量
snippet.localSet.title=局部变量-设置变量
snippet.localSet.desc=设置局部变量，仅在当前请求中有效
snippet.localGet.title=局部变量-获取变量
snippet.localGet.desc=获取局部变量的值
snippet.localHas.title=局部变量-检查变量存在
snippet.localHas.desc=检查局部变量是否存在
snippet.localUnset.title=局部变量-删除变量
snippet.localUnset.desc=删除指定的局部变量
snippet.localClear.title=局部变量-清空所有变量
snippet.localClear.desc=清空所有局部变量
snippet.localBatchSet.title=局部变量-批量设置
snippet.localBatchSet.desc=批量设置多个局部变量
snippet.localForeach.title=局部变量-遍历所有变量
snippet.localForeach.desc=遍历已知的局部变量
snippet.localConditionalSet.title=局部变量-条件设置
snippet.localConditionalSet.desc=根据条件动态设置局部变量
snippet.localDefault.title=局部变量-默认值处理
snippet.localDefault.desc=获取局部变量并提供默认值
snippet.envSet.title=设置环境变量
snippet.envSet.desc=设置环境变量
snippet.envGet.title=获取环境变量
snippet.envGet.desc=获取环境变量
snippet.envUnset.title=删除环境变量
snippet.envUnset.desc=删除环境变量
snippet.envClear.title=清空环境变量
snippet.envClear.desc=清空所有环境变量
snippet.foreachArray.title=循环遍历数组
snippet.foreachArray.desc=遍历JSON数组字段list
snippet.ifElse.title=条件判断
snippet.ifElse.desc=根据响应状态码进行条件判断
snippet.printLog.title=打印日志
snippet.printLog.desc=打印日志到控制台
snippet.base64Encode.title=Base64编码
snippet.base64Encode.desc=使用btoa进行Base64编码
snippet.base64Decode.title=Base64解码
snippet.base64Decode.desc=使用atob进行Base64解码
snippet.urlEncode.title=URL编码
snippet.urlEncode.desc=使用encodeURIComponent进行URL编码
snippet.urlDecode.title=URL解码
snippet.urlDecode.desc=使用decodeURIComponent进行URL解码
snippet.strSubstring.title=字符串截取
snippet.strSubstring.desc=截取字符串的一部分
snippet.strReplace.title=字符串替换
snippet.strReplace.desc=替换字符串中的内容
snippet.strSplit.title=字符串分割
snippet.strSplit.desc=将字符串分割为数组
snippet.getTimestamp.title=获取当前时间戳
snippet.getTimestamp.desc=获取当前的毫秒时间戳
snippet.formatDate.title=格式化日期
snippet.formatDate.desc=格式化日期为ISO字符串
snippet.jsonToObj.title=JSON字符串转对象
snippet.jsonToObj.desc=将JSON字符串转换为JavaScript对象
snippet.objToJson.title=对象转JSON字符串
snippet.objToJson.desc=将JavaScript对象转换为JSON字符串
snippet.arrayFilter.title=数组过滤
snippet.arrayFilter.desc=过滤数组中的元素
snippet.arrayMap.title=数组映射
snippet.arrayMap.desc=映射数组中的每个元素
snippet.regexExtract.title=正则匹配提取
snippet.regexExtract.desc=使用正则表达式提取匹配内容
snippet.md5.title=MD5加密
snippet.md5.desc=计算MD5哈希值
snippet.sha256.title=SHA256加密
snippet.sha256.desc=计算SHA256哈希值
# SnippetDialog
snippet.dialog.title=代码片段
snippet.dialog.preview.title=代码预览
snippet.dialog.insert=插入
snippet.dialog.close=关闭
snippet.dialog.select_snippet_first=请先选择一个代码片段
snippet.dialog.tip=提示
snippet.dialog.category.all=全部分类
snippet.dialog.category.pre_script=前置脚本
snippet.dialog.category.assert=断言脚本
snippet.dialog.category.extract=提取脚本
snippet.dialog.category.local_var=局部变量
snippet.dialog.category.env_var=环境变量
snippet.dialog.category.encrypt=加密与安全
snippet.dialog.category.encode=编码与解码
snippet.dialog.category.string=字符串操作
snippet.dialog.category.array=数组操作
snippet.dialog.category.json=JSON处理
snippet.dialog.category.date=日期时间
snippet.dialog.category.regex=正则表达式
snippet.dialog.category.log=日志调试
snippet.dialog.category.control=流程控制
snippet.dialog.category.token=令牌处理
snippet.dialog.category.other=其他工具
snippet.dialog.not_found=未找到匹配的代码片段
# WaterfallChartPanel i18n
waterfall.http_version=HTTP版本：
waterfall.local_address=本地地址：
waterfall.remote_address=远程地址：
waterfall.tls_protocol=TLS协议：
waterfall.cipher_name=加密套件：
waterfall.certificate_cn=证书CN：
waterfall.issuer_cn=颁发者CN：
waterfall.valid_until=有效期至：
waterfall.stage.dns=DNS解析
waterfall.stage.socket=建立连接
waterfall.stage.ssl=SSL握手
waterfall.stage.request_send=请求发送
waterfall.stage.waiting=等待响应（TTFB）
waterfall.stage.content_download=内容下载
waterfall.stage.desc.dns=（DnsStart→DnsEnd）
waterfall.stage.desc.socket=（ConnectStart→ConnectEnd）
waterfall.stage.desc.ssl=（SecureConnectStart→SecureConnectEnd）
waterfall.stage.desc.request_send=（RequestHeadersStart→RequestBodyEnd）
waterfall.stage.desc.waiting=（RequestBodyEnd→ResponseHeadersStart）
waterfall.stage.desc.content_download=（ResponseBodyStart→ResponseBodyEnd）
workspace.operation.success=操作成功！
workspace.operation.completed_closing=操作完成，正在关闭对话框...
workspace.operation.failed=操作失败
workspace.operation.failed_tip=请检查输入后重试
workspace.operation.failed_detail=操作失败：{0}
# GitOperationDialog 国际化
git.dialog.workspace=工作区: {0}
git.dialog.currentBranch=当前分支: {0}
git.dialog.unknown=未知
git.dialog.remoteBranch=远程分支: {0}
git.dialog.notSet=未设置
git.dialog.statusCheck=状态检查
git.dialog.checkingStatus=正在检查Git状态...
git.dialog.fileChanges=文件变更
git.dialog.loadingFileChanges=正在加载文件变更信息...
git.dialog.commitMessage=提交信息 *
git.dialog.defaultCommitMessage=Update at {0}
git.dialog.checkingStatusAndConflict=正在检查Git状态和潜在冲突...
git.dialog.statusCheckDone=Git状态检查完成
git.dialog.statusCheckFailed=状态检查失败: {0}
git.dialog.statusSummary=📊 Git 状态摘要:
git.dialog.hasUncommittedChanges=📝 有未提交变更:
git.dialog.hasLocalCommits=📦 有本地提交:
git.dialog.hasRemoteCommits=有远程新提交:
git.dialog.localAhead=• 本地领先: {0} 个提交
git.dialog.remoteAhead=• 远程领先: {0} 个提交
git.dialog.warnings=❗ 警告:
git.dialog.suggestions=💡 建议:
git.dialog.yes=✅
git.dialog.no=❌
git.operation.commit=提交
git.operation.push=推送
git.operation.pull=拉取
git.dialog.option.commit.title=💡 请选择提交方式：
git.dialog.option.commit_first=仅提交本地变更
git.dialog.option.commit_first.desc=只执行提交操作
git.dialog.option.commit_and_push=提交并推送
git.dialog.option.commit_and_push.desc=提交后自动推送到远程仓库（适合多人协作）
git.dialog.option.pull.conflict_title=❗检测到文件冲突，请选择处理方式
git.dialog.option.cancel=取消操作，在外部工具处理
git.dialog.option.cancel.desc=推荐在Git客户端或IDE中手动处理冲突
git.dialog.option.force_pull=强制拉取（丢弃本地变更）
git.dialog.option.force_pull.desc=❗避免冲突但会丢失本地变更
# 步骤指示器
step.checkStatus=检查状态
step.confirmChange=确认变更
step.selectStrategy=选择策略
step.executeOperation=执行操作
# GitOperationDialog missing i18n translations
git.dialog.option.pull.uncommittedAutoMerge.title=💡 检测到未提交变更，可自动合并
git.dialog.option.pull.uncommittedChoose.title=💡 检测到未提交变更，请选择处理方式：
git.dialog.option.commitFirstPull=先提交本地变更，再拉取
git.dialog.option.commitFirstPull.autoMergeDesc=本地变更可自动合并
git.dialog.option.forcePullDiscard=强制拉取（丢弃本地变更）
git.dialog.option.forcePullDiscard.warningDesc=❗此操作会丢弃所有未提交的本地变更，请谨慎使用
git.dialog.option.commitFirstPull.keepDesc=保留所有变更
git.dialog.option.stashPull=暂存本地变更，拉取后恢复
git.dialog.option.stashPull.desc=适用于临时变更
git.dialog.option.forcePull.loseDesc=❗将丢失未提交的变更
# Push 操作相关选项
git.dialog.option.push.conflictTitle=❗检测到文件冲突，请选择处理方式
git.dialog.option.cancelExternalTool=取消操作，在外部工具处理
git.dialog.option.cancelExternalTool.desc=推荐在Git客户端或IDE中手动处理冲突
git.dialog.option.forcePushOverwrite=强制推送（覆盖远程变更）
git.dialog.option.forcePushOverwrite.commitsDesc=❗将覆盖远程的 {0} 个提交
git.dialog.option.push.remoteAutoMerge.title=💡 远程仓库有新提交，可自动合并
git.dialog.option.pullFirstPush=先拉取远程变更，再推送
git.dialog.option.pullFirstPush.desc=无冲突，可安全自动合并
git.dialog.option.forcePushOverwrite.remoteDesc=❗将覆盖远程仓库的变更
git.dialog.option.push.remoteChoose.title=💡 远程仓库有新提交，请选择处理方式：
# 文件变更相关
git.dialog.fileChanges.notAvailable=📁 未获取到文件变更信息。
git.dialog.localChanges.title=📁 本地变更文件:
git.dialog.remoteChanges.title=远程变更文件:
git.dialog.addedFiles=• 新增文件:
git.dialog.changedFiles=• 变更文件:
git.dialog.modifiedFiles=• 修改文件:
git.dialog.removedFiles=• 删除文件:
git.dialog.missingFiles=• 丢失文件:
git.dialog.untrackedFiles=• 未跟踪文件:
git.dialog.conflictingFiles=• 冲突文件:
git.dialog.noLocalChanges=• 无本地变更
git.dialog.remoteAddedFiles=• 远程新增文件:
git.dialog.remoteModifiedFiles=• 远程修改文件:
git.dialog.remoteRemovedFiles=• 远程删除文件:
git.dialog.remoteRenamedFiles=• 远程重命名文件:
git.dialog.remoteCopiedFiles=• 远程复制文件:
git.dialog.noRemoteChanges=• 无远程变更
# 冲突详情相关
git.dialog.conflictDetails.title=❗ 冲突文件详情:
git.dialog.conflictFile=• 文件:
git.dialog.conflictBlock=冲突块
git.dialog.conflictBlock.lines=: 行[
git.dialog.conflictBase=Base:
git.dialog.conflictLocal=Local:
git.dialog.conflictRemote=Remote:
git.dialog.noConflictDetails=(无详细冲突块信息)
git.dialog.noFileConflicts=• 无文件冲突
# 操作执行相关
git.dialog.operation.completed=操作完成
git.dialog.operation.successMessage={0} 操作执行成功！
git.dialog.operation.successTitle=操作成功
git.dialog.operation.failed=操作失败: {0}
git.dialog.operation.failedMessage=操作失败: {0}
git.dialog.operation.failedTitle=操作失败
git.dialog.operation.executing=正在执行操作...
git.dialog.operation.executingProgress=正在执行 {0} 操作...
# 各种操作进度消息
git.dialog.progress.committing=正在提交变更...
git.dialog.progress.remoteCommitsPullFirst=检测到远程有新提交，先拉取远程变更...
git.dialog.progress.commitDonePushing=提交完成，正在推送到远程仓库...
git.dialog.progress.forcePushing=正在强制推送到远程仓库...
git.dialog.progress.pullFirst=先拉取远程变更...
git.dialog.progress.thenPush=然后推送本地变更...
git.dialog.progress.pushing=正在推送到远程仓库...
git.dialog.progress.commitLocalFirst=先提交本地变更...
git.dialog.progress.thenPull=然后拉取远程变更...
git.dialog.progress.stashing=暂存本地变更...
git.dialog.progress.pullingRemote=拉取远程变更...
git.dialog.progress.restoringStash=恢复暂存的变更...
git.dialog.progress.forcePullDiscard=强制拉取（丢弃本地变更）...
git.dialog.progress.pullingFromRemote=正在从远程仓库拉取...
git.dialog.userCancelled=用户取消操作
# 验证相关
git.dialog.validation.commitMessage.empty=请输入提交信息
git.dialog.validation.commitMessage.title=提交信息不能为空
# ============ GitConflictDetector 国际化 ============
# 基本检查错误消息
git.conflictDetector.checkFailed=无法检查Git状态: {0}
git.conflictDetector.noRemoteRepo=当前分支没有设置远程仓库
git.conflictDetector.noUpstreamBranch=当前分支没有设置远程跟踪分支
git.conflictDetector.cannotDetectRemoteChanges=无法检测远程分支变更类型: {0}
git.conflictDetector.cannotGetLatestRemote=无法获取最新远程状态: {0}
git.conflictDetector.cannotCheckRemote=无法检查远程状态: {0}
git.conflictDetector.cannotCountCommits=无法统计提交信息: {0}
# 远程仓库状态建议
git.conflictDetector.remoteRepoEmpty=远程仓库为空
git.conflictDetector.remoteNoSameBranch=远程仓库没有同名分支
git.conflictDetector.waitingFirstPush=等待首次推送内容
git.conflictDetector.remoteHasNewCommits=远程仓库有新提交，推送可能失败，建议先拉取
# Init 类型工作区检测
git.conflictDetector.initRemoteBranchExists=检测到远程仓库已存在同名分支，可能存在文件冲突
git.conflictDetector.initBackupSuggestion=建议先备份本地文件，然后谨慎处理合并
git.conflictDetector.initSafeFirstPush=远程仓库没有同名分支，首次推送相对安全
git.conflictDetector.initCannotGetRemoteInfo=无法获取远程分支信息进行冲突检测
git.conflictDetector.initCheckNetworkAuth=建议检查网络连接和认证信息
# 文件冲突检查相关
git.conflictDetector.checkInitConflictsFailed=检查 init 类型冲突失败: {0}
git.conflictDetector.fileConflictsDetected=检测到 {0} 个文件可能存在内容冲突
git.conflictDetector.conflictFiles=冲突文件: {0}
git.conflictDetector.moreFilesConflict=还有 {0} 个文件可能冲突
git.conflictDetector.gitMergeSuggestion=建议使用 'git merge' 或手动解决冲突
# 建议生成相关
git.conflictDetector.unknownOperationType=未知的操作类型: {0}
git.conflictDetector.canCommitChanges=可以提交变更
git.conflictDetector.modifiedFilesWillBeCommitted=已修改的文件将被提交
git.conflictDetector.noChangesToCommit=没有要提交的变更
git.conflictDetector.allFilesUpToDate=所有文件都已是最新状态且已提交
git.conflictDetector.uncommittedChangesCannotPush=有未提交的变更，无法推送
git.conflictDetector.commitFirstThenPush=请先提交所有变更，然后再推送
# Push 建议相关
git.conflictDetector.divergedHistory=❗️ 本地和远程有分歧的提交历史
git.conflictDetector.localAheadCommits=本地领先 {0} 个提交
git.conflictDetector.remoteAheadCommits=远程领先 {0} 个提交
git.conflictDetector.pullFirstOrForcePush=建议先拉取远程变更进行合并，或使用强制推送
git.conflictDetector.forcePushOverwriteCommits=强制推送将覆盖远程的 {0} 个提交
git.conflictDetector.remoteHasNewCommitsWarn=远程仓库有新的提交
git.conflictDetector.remoteAheadCommitsCount=远程领先 {0} 个提交
git.conflictDetector.pullFirstThenPush=建议先拉取远程变更，然后再推送
git.conflictDetector.avoidPushConflicts=这样可以避免推送冲突
git.conflictDetector.safePushLocalCommits=可以安全推送 {0} 个本地提交
git.conflictDetector.remoteSyncAfterPush=推送后远程仓库将与本地同步
# 首次推送建议相关
git.conflictDetector.firstPushOverwriteWarning=❗️ 首次推送可能覆盖远程分支已有内容
git.conflictDetector.filesMayConflict=检测到 {0} 个文件可能冲突
git.conflictDetector.useForceWithLease=建议使用 --force-with-lease 进行安全的强制推送
git.conflictDetector.pullRemoteFirst=或者先拉取远程分支内容进行手动合并
git.conflictDetector.confirmOverwriteFiles=推送前请确认要覆盖的远程文件
git.conflictDetector.remoteEmptySafePush=✅ 远程仓库为空，首次推送安全
git.conflictDetector.pushCommitsToRemote=将推送 {0} 个本地提交到远程仓库
git.conflictDetector.autoSetUpstream=推送后将自动设置上游分支跟踪
git.conflictDetector.firstPushDetected=检测到首次推送情况
git.conflictDetector.pushCommitsCount=将推送 {0} 个本地提交
git.conflictDetector.setUpstreamTracking=推送后将设置上游分支跟踪
# Pull 建议相关
git.conflictDetector.cannotPullFileConflicts=❗️ 无法直接拉取：检测到潜在的文件冲突
git.conflictDetector.manualHandleConflicts=建议先手动处理文件冲突：
git.conflictDetector.backupLocalFiles=1. 备份当前本地文件
git.conflictDetector.gitFetchOrigin=2. 使用 git fetch origin 获取远程分支
git.conflictDetector.manualMergeFiles=3. 手动合并冲突文件
git.conflictDetector.createMergeCommit=4. 创建合并提交
git.conflictDetector.cannotPullNoUpstream=无法拉取：当前分支没有设置远程跟踪分支
git.conflictDetector.configRemoteFirst=请先配置远程仓库并设置上游分支
git.conflictDetector.firstPushEstablishTracking=或者先进行首次推送以建立跟踪关系
git.conflictDetector.remoteRepoStatusEmpty=📍 远程仓库状态：远程仓库当前为空
git.conflictDetector.canTryPullNoContent=虽然可以尝试拉取，但远程仓库没有内容可拉取
git.conflictDetector.pushLocalContentFirst=建议先向远程仓库推送本地内容
git.conflictDetector.uncommittedPullConflicts=有未提交的变更，拉取可能导致冲突
git.conflictDetector.commitOrStashFirst=建议先提交或暂存本地变更
git.conflictDetector.forcePullLoseChanges=或者选择强制拉取（将丢弃本地未提交变更）
git.conflictDetector.localIsUpToDate=本地仓库已是最新状态
git.conflictDetector.safePullRemoteCommits=可以安全拉取 {0} 个远程提交
# 冲突检测相关
git.conflictDetector.noCommonHistory=本地和远程分支没有共同的提交历史
git.conflictDetector.actualFileConflicts=检测到 {0} 个文件存在实际冲突
git.conflictDetector.conflictFilesList=冲突文件: {0}
git.conflictDetector.moreConflictFiles=还有 {0} 个文件存在冲突
git.conflictDetector.nonOverlappingChanges=✅ 检测到非重叠变更，可以安全自动合并
git.conflictDetector.onlyNewFilesSafe=✅ 只包含新文件，可以安全合并
# WorkspaceCreateDialog specific translations
workspace.create.dialog.branch.label=分支:
workspace.create.dialog.creating=正在创建工作区...
workspace.create.dialog.creation.completed=工作区创建完成！
workspace.create.dialog.creation.failed=创建工作区失败
workspace.create.dialog.creation.failed.with.message=创建工作区失败: {0}
# ProgressDialog translations
progress.dialog.operation.success=操作成功！
progress.dialog.operation.completed.closing=操作完成，正在关闭对话框...
progress.dialog.operation.failed=操作失败
progress.dialog.check.input.retry=请检查输入信息后重试
progress.dialog.operation.failed.with.message=操作失败: {0}
progress.dialog.confirm.cancel.operation=操作正在进行中，确定要取消吗？
progress.dialog.confirm.cancel.title=确认取消
# ProgressPanel translations
progress.panel.ready=准备就绪
progress.panel.fill_config=请填写配置信息
# ============ 代理设置相关 ============
settings.proxy.title=网络代理设置
settings.proxy.enabled=启用网络代理:
settings.proxy.enabled.tooltip=从内网访问公网API时启用网络代理
settings.proxy.enabled.checkbox=启用网络代理
settings.proxy.type=代理类型:
settings.proxy.type.tooltip=选择代理服务器类型：HTTP 或 SOCKS
settings.proxy.type.http=HTTP
settings.proxy.type.socks=SOCKS
settings.proxy.host=代理服务器地址:
settings.proxy.host.tooltip=代理服务器的IP地址或域名
settings.proxy.port=代理端口:
settings.proxy.port.tooltip=代理服务器的端口号
settings.proxy.username=用户名（可选）:
settings.proxy.username.tooltip=代理服务器认证用户名（可选）
settings.proxy.password=密码（可选）:
settings.proxy.password.tooltip=代理服务器认证密码（可选）
settings.proxy.ssl.verification=SSL证书验证:
settings.proxy.ssl.verification.tooltip=禁用SSL证书验证以解决SOCKS代理环境下的SSL握手问题（降低安全性）
settings.proxy.ssl.verification.checkbox=禁用SSL证书验证
settings.validation.proxy_port.error=代理端口必须是正整数
# 内置变量
builtin.var.guid=生成全局唯一标识符（v4 UUID）
builtin.var.uuid=生成随机 UUID
builtin.var.randomUUID=生成随机 UUID
builtin.var.timestamp=当前时间戳（秒）
builtin.var.isoTimestamp=ISO 8601 格式时间戳
builtin.var.randomInt=随机整数（0-1000）
builtin.var.randomAlphaNumeric=随机字母数字字符串（10位）
builtin.var.randomBoolean=随机布尔值（true/false）
builtin.var.randomIP=随机 IPv4 地址
builtin.var.randomEmail=随机邮箱地址
builtin.var.randomFullName=随机姓名
builtin.var.randomFirstName=随机名字
builtin.var.randomLastName=随机姓氏
builtin.var.randomColor=随机颜色代码
builtin.var.randomDate=随机日期（年-月-日）
builtin.var.randomTime=随机时间（时:分:秒）
builtin.var.randomUrl=随机网址
builtin.var.randomPhoneNumber=随机电话号码
builtin.var.randomCity=随机城市
builtin.var.randomCountry=随机国家
builtin.var.randomUserAgent=随机浏览器标识
builtin.var.randomMD5=随机 MD5 值
builtin.var.randomBase64=随机 Base64 字符串
# 工具箱相关
toolbox.encoder=编码/解码
toolbox.encoder.title=编码类型
toolbox.encoder.input=输入
toolbox.encoder.output=输出
toolbox.encoder.encode=编码
toolbox.encoder.decode=解码
toolbox.crypto=加密工具
toolbox.crypto.algorithm=算法
toolbox.crypto.mode=模式
toolbox.crypto.key=密钥
toolbox.crypto.iv=初始化向量 (IV)
toolbox.crypto.input=输入文本
toolbox.crypto.output=输出结果
toolbox.crypto.encrypt=加密
toolbox.crypto.decrypt=解密
toolbox.crypto.generate_key=生成密钥
toolbox.crypto.generate_iv=生成IV
toolbox.crypto.base64url=Base64 URL安全
toolbox.crypto.base64url.tooltip=使用URL安全的Base64编码（将 + 替换为 -，/ 替换为 _）
toolbox.crypto.error.key_required=加密/解密需要密钥
toolbox.crypto.error.key_length=密钥长度必须为 {0} 个字符（{1}）
toolbox.crypto.error.iv_required={0} 模式需要初始化向量 (IV)
toolbox.crypto.error.iv_length=IV 长度必须为 {0} 个字符
toolbox.crypto.error.input_empty=请输入要加密/解密的文本
toolbox.crypto.success.encrypted=✅ 加密结果（Base64）：
toolbox.crypto.success.decrypted=✅ 解密结果：
toolbox.crypto.key.placeholder.aes128=AES-128 需要16个字符的密钥
toolbox.crypto.key.placeholder.aes256=AES-256 需要32个字符的密钥
toolbox.crypto.key.placeholder.des=DES 需要8个字符的密钥
toolbox.crypto.iv.placeholder=CBC模式需要16个字符的IV（AES）或8个字符（DES）
toolbox.json=JSON工具
toolbox.json.format=格式化
toolbox.json.compress=压缩
toolbox.json.validate=验证
toolbox.json.escape=转义
toolbox.json.unescape=反转义
toolbox.json.sort_keys=排序键
toolbox.json.swap=交换
toolbox.json.paste=粘贴
toolbox.json.input=输入JSON
toolbox.json.output=输出结果
toolbox.json.error=JSON格式错误
toolbox.json.status.empty=输入为空
toolbox.json.status.formatted=✅ 格式化成功 - {0} 行，{1} 字符
toolbox.json.status.compressed=✅ 压缩完成 - 节省 {0} 字符 ({1}%)
toolbox.json.status.validated=✅ 有效的 JSON - {0}
toolbox.json.status.invalid=❌ 无效的 JSON
toolbox.json.status.escaped=✅ 转义成功
toolbox.json.status.unescaped=✅ 反转义成功
toolbox.json.status.sorted=✅ 键已按字母顺序排序
toolbox.json.status.swapped=↕ 已交换输入和输出
toolbox.json.status.copied=✅ 已复制到剪贴板
toolbox.json.status.pasted=✅ 已从剪贴板粘贴
toolbox.json.status.cleared=已清空
toolbox.json.status.output_empty=⚠️ 输出为空
toolbox.json.status.not_object=⚠️ 不是 JSON 对象
toolbox.json.validation.empty=⚠️ 输入为空
toolbox.json.validation.valid=✅ 有效的 JSON
toolbox.json.validation.type=类型
toolbox.json.validation.characters=字符数
toolbox.json.validation.lines=行数
toolbox.json.validation.keys=键数
toolbox.json.validation.array_length=数组长度
toolbox.json.tooltip.format=使用缩进格式化 JSON (Ctrl+Shift+F)
toolbox.json.tooltip.compress=压缩 JSON 为单行 (Ctrl+Shift+C)
toolbox.json.tooltip.validate=验证 JSON 语法 (Ctrl+Shift+V)
toolbox.json.tooltip.escape=转义特殊字符
toolbox.json.tooltip.unescape=反转义特殊字符
toolbox.json.tooltip.sort=按字母顺序排序 JSON 键
toolbox.json.tooltip.copy=复制输出到剪贴板 (Ctrl+C)
toolbox.json.tooltip.paste=从剪贴板粘贴 (Ctrl+V)
toolbox.json.tooltip.clear=清空两个区域 (Ctrl+L)
toolbox.json.tooltip.swap=交换输入和输出内容
toolbox.timestamp=时间戳转换
toolbox.timestamp.current=当前时间戳
toolbox.timestamp.input=输入时间戳
toolbox.timestamp.output=转换结果
toolbox.timestamp.milliseconds=毫秒
toolbox.timestamp.seconds=秒
toolbox.timestamp.toDate=转换为日期
toolbox.timestamp.dateToTimestamp=日期转时间戳
toolbox.timestamp.dateInput=日期输入
toolbox.timestamp.dateFormatHint=格式：yyyy-MM-dd HH:mm:ss
toolbox.timestamp.nowButton=当前时间
toolbox.timestamp.nowTooltip=填充当前日期时间
toolbox.timestamp.clearButton=清空
toolbox.timestamp.formattedDates=📅 格式化日期
toolbox.timestamp.standard=标准格式
toolbox.timestamp.iso8601=ISO 8601
toolbox.timestamp.httpDate=HTTP 日期
toolbox.timestamp.timestamps=⏱️ 时间戳
toolbox.timestamp.additionalInfo=📊 附加信息
toolbox.timestamp.dayOfWeek=星期
toolbox.timestamp.weekOfYear=年周数
toolbox.timestamp.error=❌ 错误
toolbox.timestamp.invalidDateFormat=日期格式无效
toolbox.timestamp.expectedFormat=期望格式
toolbox.timestamp.example=示例
toolbox.timestamp.inputDate=📅 输入日期
toolbox.uuid=UUID生成器
toolbox.uuid.generate=生成UUID
toolbox.uuid.count=数量
toolbox.uuid.format=格式
toolbox.uuid.uppercase=大写
toolbox.uuid.with_hyphens=带连字符
toolbox.uuid.without_hyphens=不带连字符
toolbox.uuid.version_info=ℹ️ UUID Version 4 (随机)
toolbox.uuid.generated=已生成
toolbox.uuid.batch_generate=批量生成
toolbox.uuid.version=版本
toolbox.uuid.separator=分隔符
toolbox.uuid.separator_newline=换行
toolbox.uuid.separator_comma=逗号
toolbox.uuid.separator_space=空格
toolbox.uuid.separator_semicolon=分号
toolbox.uuid.copy_one=复制第一个
toolbox.uuid.export=导出
toolbox.uuid.export_success=导出成功
toolbox.uuid.export_failed=导出失败
toolbox.uuid.empty=没有可复制的UUID
toolbox.uuid.parse=解析UUID
toolbox.uuid.input=输入UUID
toolbox.uuid.parse_empty=请输入要解析的UUID
toolbox.uuid.parse_invalid=无效的UUID格式
toolbox.uuid.parse_result=解析结果
toolbox.uuid.standard_format=标准格式
toolbox.uuid.variant=变体
toolbox.uuid.timestamp=时间戳
toolbox.uuid.namespace=命名空间
toolbox.uuid.namespace_custom=自定义
toolbox.uuid.namespace_hint=输入自定义命名空间UUID或从预定义中选择
toolbox.uuid.name=名称
toolbox.uuid.name_based=基于名称的UUID
toolbox.uuid.name_based_desc=使用哈希算法从命名空间和名称生成
toolbox.hash=Hash计算
toolbox.hash.input=输入文本
toolbox.hash.output=哈希结果
toolbox.hash.calculate_all=计算全部
toolbox.hash.calculate_all.tooltip=一次性计算所有哈希算法
toolbox.hash.uppercase=大写
toolbox.hash.uppercase.tooltip=以大写字母显示哈希结果
toolbox.diff=文本对比
toolbox.diff.original=原始文本
toolbox.diff.modified=修改文本
toolbox.diff.compare=对比
toolbox.diff.result=对比结果
toolbox.cron=Cron表达式
toolbox.cron.expression=Cron表达式
toolbox.cron.parse=解析
toolbox.cron.generate=生成
toolbox.cron.description=描述
toolbox.cron.next_executions=下次执行时间
toolbox.cron.tab.parse=解析Cron
toolbox.cron.tab.generate=生成Cron
toolbox.cron.placeholder=输入cron表达式 (例如: 0 0 12 * * ?)
toolbox.cron.execution_time=执行时间
toolbox.cron.format=Cron格式
toolbox.cron.second=秒 (0-59)
toolbox.cron.minute=分钟 (0-59)
toolbox.cron.hour=小时 (0-23)
toolbox.cron.day=日 (1-31)
toolbox.cron.month=月 (1-12)
toolbox.cron.week=周 (0-7)
toolbox.cron.year=年 (可选)
toolbox.cron.year.optional=年 (可选)
toolbox.cron.year.placeholder=输入年份 (可选)
toolbox.cron.generated=生成的Cron
toolbox.cron.quick_presets=快速预设
toolbox.cron.common_presets=常用预设
toolbox.cron.special_chars=特殊字符
toolbox.cron.common_expressions=常用Cron表达式
toolbox.cron.preset.every_second=每秒
toolbox.cron.preset.every_minute=每分钟
toolbox.cron.preset.every_5min=每5分钟
toolbox.cron.preset.every_15min=每15分钟
toolbox.cron.preset.every_30min=每30分钟
toolbox.cron.preset.every_hour=每小时
toolbox.cron.preset.every_2hour=每2小时
toolbox.cron.preset.daily_noon=每天中午12点
toolbox.cron.preset.daily_midnight=每天午夜0点
toolbox.cron.preset.monday_9am=每周一上午9点
toolbox.cron.preset.weekday_9am=工作日上午9点
toolbox.cron.preset.first_day_month=每月第一天
toolbox.cron.preset.last_day_month=每月最后一天
toolbox.cron.error.empty=请输入Cron表达式
toolbox.cron.error.invalid=❌ 无效的Cron表达式。期望格式:\n秒 分钟 小时 日 月 周 [年]
toolbox.cron.error.parse=❌ 解析Cron表达式出错
toolbox.cron.analysis=✅ Cron表达式分析
toolbox.cron.fields=字段
toolbox.cron.unable_calculate=无法计算执行时间
# 客户端证书
cert.title=客户端证书
cert.add=添加证书
cert.edit=编辑证书
cert.delete=删除
cert.delete.confirm=确定要删除证书配置 "{0}" 吗？
cert.name=名称
cert.host=主机名
cert.port=端口
cert.cert_type=证书类型
cert.cert_path=证书文件
cert.key_path=私钥文件
cert.password=密码
cert.enabled=启用
cert.select_file=选择文件
cert.type.pfx=PFX/P12
cert.type.pem=PEM
cert.port.all=所有端口
cert.port.placeholder=端口号，留空或0表示所有端口
cert.host.placeholder=例如: api.example.com 或 *.example.com
cert.name.placeholder=可选：为此证书配置命名
cert.cert_path.placeholder=选择证书文件 (.pfx, .p12, .pem, .crt)
cert.key_path.placeholder=选择私钥文件 (.key, .pem)
cert.validation.host_required=主机名不能为空
cert.validation.cert_required=证书文件不能为空
cert.validation.key_required=PEM格式需要私钥文件
cert.validation.file_not_found=文件不存在: {0}
cert.save=保存
cert.cancel=取消
cert.help=帮助
cert.help.title=客户端证书配置说明
cert.help.content=客户端证书用于 mTLS (mutual TLS) 认证。\n\n支持的证书格式：\n• PFX/P12: 包含证书和私钥的单一文件\n• PEM: 分离的证书文件和私钥文件\n\n主机名匹配：\n• 精确匹配: api.example.com\n• 通配符匹配: *.example.com\n\n端口配置：\n• 0 表示匹配所有端口\n• 指定端口号仅匹配特定端口\n\n优先级：第一个匹配的启用证书将被使用。
cert.close=关闭
cert.error=错误
cert.description=配置客户端证书用于 mTLS 认证。支持 PFX/P12 和 PEM 格式。证书将根据主机名和端口自动匹配并应用到请求中。
# 客户端证书控制台日志
cert.console.matched=🔐 客户端证书匹配: {0}:{1} -> [{2}] {3}
cert.console.loaded=✅ 客户端证书加载成功: {0}
cert.console.load_failed=❌ 客户端证书加载失败: {0} - {1}
cert.console.validation_failed=⚠️  客户端证书验证失败: {0}
cert.console.file_not_found=❌ 证书文件不存在或不可读: {0}