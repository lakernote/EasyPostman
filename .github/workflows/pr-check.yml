# 工作流名称：Pull Request 检查
#
# 作用：在 PR 合并前进行自动化质量检查，确保代码质量
# 包括：构建测试、代码质量检查、PR 规范验证、跨平台打包和功能测试
name: PR Check

# 触发条件：当创建或更新 Pull Request 时
on:
  pull_request:
    # 目标分支：main、master、develop
    branches:
      - main
      - master
      - develop
    # 触发类型：
    # - opened: PR 首次创建时
    # - synchronize: PR 有新提交推送时
    # - reopened: 关闭的 PR 重新打开时
    types: [opened, synchronize, reopened]

# 环境变量：定义跨平台打包所需的配置
env:
  JAVA_VERSION: '17'
  JAVA_DISTRIBUTION: 'temurin'
  JLINK_MODULES: 'java.base,java.desktop,java.logging,jdk.unsupported,java.naming,java.net.http,java.prefs,java.sql,java.security.sasl,java.security.jgss,jdk.crypto.ec,java.management,java.management.rmi,jdk.crypto.cryptoki'
  JAVA_OPTIONS: '-Xms256m|-Xmx512m|-Dfile.encoding=UTF-8'

jobs:
  # Job 0: 获取版本号（供所有 Job 使用）
  get-version:
    name: Get Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract_version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: 'maven'

      - name: Extract version
        id: extract_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # Job 1: 构建和测试（生成跨平台 JAR）
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [get-version]

    steps:
      # 第一步：检出代码
      - name: Checkout code
        uses: actions/checkout@v4

      # 第二步：设置 Java 17 环境（已包含 Maven 缓存功能）
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: 'maven'

      # 第三步：使用 Maven 构建项目（跳过测试以加快构建速度）
      - name: Build with Maven
        run: mvn clean package -DskipTests -B

      # 第四步：运行单元测试
      - name: Run tests
        run: mvn test
        continue-on-error: true  # 即使测试失败也继续执行后续步骤

      # 第五步：JAR 启动测试（验证 IOC 容器扫描等核心功能）
      - name: Test JAR startup
        timeout-minutes: 2
        run: |
          echo "🧪 Testing JAR startup and IOC container..."
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          JAR_FILE="target/easy-postman-${VERSION}.jar"
          
          if [ ! -f "$JAR_FILE" ]; then
            echo "❌ JAR file not found: $JAR_FILE"
            exit 1
          fi
          
          echo "✅ JAR file exists: $JAR_FILE ($(du -h $JAR_FILE | cut -f1))"
          
          # 启动应用（后台运行，headless 模式）
          java -jar "$JAR_FILE" > jar-test-stdout.log 2> jar-test-stderr.log &
          JAR_PID=$!
          
          echo "✅ JAR started (PID: $JAR_PID)"
          
          # 等待应用启动和 IOC 容器初始化
          sleep 10
          
          # 检查进程是否还在运行
          if ps -p $JAR_PID > /dev/null 2>&1; then
            echo "✅ JAR is running successfully"
            
            # 检查日志中是否有 IOC 容器初始化成功的标志
            if grep -q "IOC container initialized successfully" jar-test-stdout.log jar-test-stderr.log 2>/dev/null; then
              echo "✅ IOC container initialized successfully"
            else
              echo "❌ IOC container initialization not detected in logs"
              echo "=== Checking for errors in logs ==="
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            # 检查是否有 Bean 注册失败的错误
            if grep -i "NoSuchBeanException" jar-test-stdout.log jar-test-stderr.log 2>/dev/null; then
              echo "❌ Bean registration failed - NoSuchBeanException detected"
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            # 检查注册的 Bean 数量
            BEAN_COUNT=$(grep -oP "Total registered beans: \[\K\d+" jar-test-stdout.log jar-test-stderr.log 2>/dev/null | head -1 || echo "0")
            echo "📊 Total registered beans: $BEAN_COUNT"
            
            if [ "$BEAN_COUNT" -eq "0" ]; then
              echo "❌ No beans registered - IOC container scanning failed!"
              echo "=== Full log output ==="
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            echo "✅ Bean scanning working correctly"
            
            # 停止应用
            kill -TERM $JAR_PID 2>/dev/null || true
            sleep 2
            if ps -p $JAR_PID > /dev/null 2>&1; then
              kill -9 $JAR_PID 2>/dev/null || true
            fi
            
            echo "✅ JAR startup test passed"
          else
            echo "❌ JAR crashed or exited immediately"
            echo "=== Error Log ==="
            cat jar-test-stderr.log || true
            echo "=== Output Log ==="
            cat jar-test-stdout.log || true
            exit 1
          fi

      # 第六步：上传 JAR 测试日志
      - name: Upload JAR test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: jar-test-logs
          path: |
            jar-test-*.log
          retention-days: 3

      # 第七步：上传测试报告
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()  # 无论测试成功或失败都上传
        with:
          name: test-results
          path: target/surefire-reports/
          retention-days: 3  # 测试报告保留 3 天即可（仅用于快速调试）

      # 第八步：上传 JAR 供后续打包任务使用
      - name: Upload JAR for packaging
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: app-jar
          path: target/easy-postman-${{ needs.get-version.outputs.version }}.jar
          retention-days: 1  # 仅供当前工作流使用

  # Job 2: Windows 打包和验证
  test-windows-package:
    name: Test Windows Package
    runs-on: windows-latest
    needs: [get-version, build]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}

      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          Write-Host "📦 Installing WiX Toolset..."
          choco install wixtoolset -y
          if (Get-Command refreshenv -ErrorAction SilentlyContinue) { 
            refreshenv 
          } else {
            $refreshScript = "$env:ChocolateyInstall\lib\refreshenv\tools\RefreshEnv.ps1"
            if (Test-Path $refreshScript) { & $refreshScript }
          }
          Write-Host "✅ WiX installed"

      - name: Create runtime with jlink
        shell: pwsh
        run: |
          Write-Host "🔧 Creating Windows runtime..."
          $runtimeDir = "target\runtime"
          if (Test-Path $runtimeDir) { Remove-Item -Recurse -Force $runtimeDir }
          
          jlink `
            --add-modules $env:JLINK_MODULES `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2 `
            --output $runtimeDir
          Write-Host "✅ Runtime created"

      - name: Prepare dist-input
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $distInputDir = "target\dist-input"
          if (Test-Path $distInputDir) { Remove-Item -Recurse -Force $distInputDir }
          New-Item -ItemType Directory -Path $distInputDir | Out-Null
          
          Copy-Item "target\$jarName" -Destination $distInputDir
          Write-Host "✅ Prepared dist-input"

      - name: Copy WiX configuration for install path memory test（复制 WiX 配置测试安装路径记忆功能）
        shell: pwsh
        run: |
          Write-Host "🔧 Copying WiX configuration to test installation path memory feature..."
          $resourceDir = "target\jpackage-resources"
          if (-not (Test-Path $resourceDir)) { New-Item -ItemType Directory -Path $resourceDir | Out-Null }
          
          # 复制 overrides.wxi（jpackage 会自动 include 这个文件）
          # 这个文件包含：
          # 1. Property + RegistrySearch（读取上次安装路径）
          # 2. SetProperty（设置 INSTALLDIR 初始值）
          # 3. DirectoryRef + Component（保存当前安装路径）
          $wixConfig = "build\overrides.wxi"
          if (-not (Test-Path $wixConfig)) {
            Write-Host "❌ WiX configuration file not found: $wixConfig"
            exit 1
          }
          
          Copy-Item $wixConfig -Destination "$resourceDir\overrides.wxi"
          Write-Host "✅ Copied overrides.wxi (install path memory enabled)"
          
          # 验证文件
          if (Test-Path "$resourceDir\overrides.wxi") {
            $fileSize = (Get-Item "$resourceDir\overrides.wxi").Length
            Write-Host "✅ overrides.wxi file size: $fileSize bytes"
            Write-Host "📄 Content preview:"
            Get-Content "$resourceDir\overrides.wxi" -Head 20
          } else {
            Write-Host "❌ Failed to copy overrides.wxi"
            exit 1
          }

      - name: Validate overrides.wxi format（验证 overrides.wxi 格式）
        shell: pwsh
        run: |
          Write-Host "🔍 Validating overrides.wxi format for WiX compatibility..."
          Write-Host ""
          
          $wixFile = "target\jpackage-resources\overrides.wxi"
          if (-not (Test-Path $wixFile)) {
            Write-Host "❌ overrides.wxi not found in resource directory"
            exit 1
          }
          
          Write-Host "📄 Complete file content:"
          Write-Host "=" * 80
          Get-Content $wixFile | ForEach-Object { Write-Host $_ }
          Write-Host "=" * 80
          Write-Host ""
          
          # 读取文件内容进行检查
          $content = Get-Content $wixFile -Raw
          
          # 检查 1: 不应该有 <?xml 声明
          Write-Host "🔍 Check 1: XML Declaration"
          if ($content -match '<\?xml\s+version') {
            Write-Host "❌ FAIL: Found <?xml declaration"
            Write-Host "   Issue: WiX include files should NOT have XML declaration"
            Write-Host "   Reason: jpackage uses <?include ?> which expects raw content"
            $hasIssues = $true
          } else {
            Write-Host "✅ PASS: No XML declaration (correct)"
          }
          
          # 检查 2: 不应该有 <Include> 根元素
          Write-Host ""
          Write-Host "🔍 Check 2: Include Root Element"
          if ($content -match '<Include\s*>') {
            Write-Host "❌ FAIL: Found <Include> root element"
            Write-Host "   Issue: overrides.wxi should NOT have <Include> wrapper"
            Write-Host "   Reason: <?include ?> directive inserts content directly"
            $hasIssues = $true
          } else {
            Write-Host "✅ PASS: No <Include> root element (correct)"
          }
          
          # 检查 3: 不应该有 <Fragment> 根元素
          Write-Host ""
          Write-Host "🔍 Check 3: Fragment Root Element"
          if ($content -match '^\s*<Fragment\s*>') {
            Write-Host "❌ FAIL: Found <Fragment> as root element"
            Write-Host "   Issue: overrides.wxi should NOT have <Fragment> wrapper"
            Write-Host "   Reason: jpackage expects direct WiX elements"
            $hasIssues = $true
          } else {
            Write-Host "✅ PASS: No <Fragment> root element (correct)"
          }
          
          # 检查 4: 不应该有 xmlns 声明
          Write-Host ""
          Write-Host "🔍 Check 4: Namespace Declaration"
          if ($content -match 'xmlns\s*=') {
            Write-Host "❌ FAIL: Found xmlns namespace declaration"
            Write-Host "   Issue: Include files should not declare namespaces"
            $hasIssues = $true
          } else {
            Write-Host "✅ PASS: No xmlns declaration (correct)"
          }
          
          # 检查 5: 应该有必需的 WiX 元素
          Write-Host ""
          Write-Host "🔍 Check 5: Required WiX Elements"
          $requiredElements = @{
            'Property.*PREVIOUSINSTALLDIR' = 'Property for reading previous install path'
            'RegistrySearch' = 'RegistrySearch for previous path'
            'SetProperty.*INSTALLDIR' = 'SetProperty for INSTALLDIR'
            'DirectoryRef.*INSTALLDIR' = 'DirectoryRef for INSTALLDIR'
            'RememberInstallDirComponent' = 'Component for saving install path'
            'RegistryValue' = 'RegistryValue for saving path'
            'InstallPathMemoryGroup' = 'ComponentGroup for install path memory'
          }
          
          $allElementsFound = $true
          foreach ($element in $requiredElements.GetEnumerator()) {
            if ($content -match $element.Key) {
              Write-Host "  ✅ $($element.Value): Found"
            } else {
              Write-Host "  ❌ $($element.Value): NOT Found"
              $allElementsFound = $false
              $hasIssues = $true
            }
          }
          
          # 总结
          Write-Host ""
          Write-Host "=" * 80
          if ($hasIssues) {
            Write-Host "❌ VALIDATION FAILED: overrides.wxi has format issues"
            Write-Host ""
            Write-Host "📝 Correct format should be:"
            Write-Host "   - No <?xml declaration"
            Write-Host "   - No <Include> wrapper"
            Write-Host "   - No <Fragment> wrapper"
            Write-Host "   - Direct WiX elements: <Property>, <SetProperty>, <DirectoryRef>, <ComponentGroup>"
            Write-Host ""
            exit 1
          } else {
            Write-Host "✅ VALIDATION PASSED: overrides.wxi format is correct"
            Write-Host "   Ready for jpackage <?include ?> directive"
          }

      - name: Check jpackage temp directory before packaging（打包前检查临时目录）
        shell: pwsh
        run: |
          Write-Host "🔍 Checking for existing jpackage temp directories..."
          $tempDirs = Get-ChildItem -Path $env:TEMP -Filter "jdk.jpackage*" -Directory -ErrorAction SilentlyContinue
          if ($tempDirs) {
            Write-Host "⚠️  Found existing jpackage temp directories, cleaning up..."
            foreach ($dir in $tempDirs) {
              Write-Host "  Removing: $($dir.FullName)"
              Remove-Item -Recurse -Force $dir.FullName -ErrorAction SilentlyContinue
            }
          } else {
            Write-Host "✅ No existing jpackage temp directories found"
          }

      - name: Create Windows MSI installer for path memory testing（创建 MSI 安装包测试路径记忆）
        shell: pwsh
        run: |
          Write-Host "📦 Creating Windows MSI installer with install path memory feature..."
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          $outDir = "target\msi-test"
          
          if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }
          
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建 Windows MSI 安装包（用于测试安装路径记忆功能）
          # Note: jpackage output is captured for better error reporting
          try {
            jpackage `
              --type msi `
              --input target\dist-input `
              --main-jar $jarName `
              --main-class com.laker.postman.App `
              --runtime-image target\runtime `
              --dest $outDir `
              --icon assets\win\EasyPostman.ico `
              --name EasyPostman `
              --app-version $version `
              --vendor "Laker" `
              --copyright "© 2025 Laker" `
              --win-shortcut `
              --win-menu `
              --description "A modern API testing tool similar to Postman" `
              --win-upgrade-uuid "28607609-97b7-4212-9285-04ef64a4946c" `
              --win-dir-chooser `
              --win-per-user-install `
              --win-menu-group "EasyTools" `
              --win-help-url "https://gitee.com/lakernote/easy-postman" `
              --resource-dir "target\jpackage-resources" `
              --java-options $javaOpts[0] `
              --java-options $javaOpts[1] `
              --java-options $javaOpts[2] `
              --java-options "-Djavax.accessibility.assistive_technologies=" `
              --temp "target\jpackage-temp" `
              --verbose
            
            if ($LASTEXITCODE -ne 0) {
              Write-Host "❌ jpackage failed with exit code: $LASTEXITCODE"
              Write-Host "💡 Checking for WiX compilation logs..."
              
              # Look for WiX log files in temp directories
              $tempDirs = @(
                "$env:TEMP\jdk.jpackage*",
                "C:\Users\*\AppData\Local\Temp\jdk.jpackage*"
              )
              
              foreach ($pattern in $tempDirs) {
                $dirs = Get-ChildItem -Path $pattern -Directory -ErrorAction SilentlyContinue
                foreach ($dir in $dirs) {
                  Write-Host "📂 Checking $dir"
                  $logFiles = Get-ChildItem -Path $dir -Recurse -Include "*.log" -ErrorAction SilentlyContinue
                  foreach ($log in $logFiles) {
                    Write-Host "📄 Log file: $($log.FullName)"
                    Get-Content $log -ErrorAction SilentlyContinue | Select-Object -Last 50
                  }
                }
              }
              
              exit 1
            }
            
            Write-Host "✅ MSI installer created successfully"
          } catch {
            Write-Host "❌ Exception during jpackage execution:"
            Write-Host $_.Exception.Message
            Write-Host $_.ScriptStackTrace
            exit 1
          }

      - name: Check WiX files in jpackage temp directory（检查jpackage临时目录中的WiX文件）
        shell: pwsh
        run: |
          Write-Host "🔍 Checking WiX files in jpackage temp directory..."
          $tempDir = "target\jpackage-temp"
          
          if (-not (Test-Path $tempDir)) {
            Write-Host "❌ Temp directory not found: $tempDir"
            exit 1
          }
          
          Write-Host "📂 Temp directory exists: $tempDir"
          
          # Find all .wxs files
          Write-Host "`n🔍 Looking for .wxs files..."
          $wxsFiles = Get-ChildItem -Path $tempDir -Recurse -Filter "*.wxs" -ErrorAction SilentlyContinue
          
          if ($wxsFiles) {
            Write-Host "✅ Found $($wxsFiles.Count) .wxs file(s):"
            foreach ($file in $wxsFiles) {
              $fileSize = $file.Length
              Write-Host "  📄 $($file.FullName) ($fileSize bytes)"
            }
            
            # Check specifically for main.wxs and overrides.wxi
            $mainWxs = $wxsFiles | Where-Object { $_.Name -eq "main.wxs" }
            $overridesWxi = Get-ChildItem -Path $tempDir -Recurse -Filter "overrides.wxi" -ErrorAction SilentlyContinue
            
            if ($mainWxs) {
              Write-Host "`n📄 Found main.wxs:"
              Write-Host "   Path: $($mainWxs.FullName)"
              Write-Host "   Size: $($mainWxs.Length) bytes"
              
              # 读取完整内容
              $mainContent = Get-Content $mainWxs.FullName -Raw
              
              Write-Host "`n📄 Main.wxs structure overview:"
              Write-Host "   Total lines: $((Get-Content $mainWxs.FullName | Measure-Object -Line).Lines)"
              
              # 检查 1: <?include overrides.wxi ?> 指令
              Write-Host "`n🔍 Check 1: Include Directive"
              if ($mainContent -match '\<\?include.*overrides\.wxi.*\?\>') {
                Write-Host "  ✅ PASS: Found <?include overrides.wxi ?> directive"
                $includeMatches = [regex]::Matches($mainContent, '\<\?include.*overrides\.wxi.*\?\>')
                foreach ($match in $includeMatches) {
                  # 找到匹配行号
                  $lines = Get-Content $mainWxs.FullName
                  for ($i = 0; $i -lt $lines.Count; $i++) {
                    if ($lines[$i] -match [regex]::Escape($match.Value)) {
                      Write-Host "     Line $($i + 1): $($lines[$i].Trim())"
                      break
                    }
                  }
                }
              } else {
                Write-Host "  ❌ FAIL: <?include overrides.wxi ?> directive NOT found"
                Write-Host "     Issue: jpackage did not include our overrides.wxi file"
              }
              
              # 检查 2: PREVIOUSINSTALLDIR Property
              Write-Host "`n🔍 Check 2: PREVIOUSINSTALLDIR Property"
              if ($mainContent -match 'PREVIOUSINSTALLDIR') {
                Write-Host "  ✅ PASS: PREVIOUSINSTALLDIR found in main.wxs"
                $propMatches = Select-String -Path $mainWxs.FullName -Pattern "PREVIOUSINSTALLDIR" -AllMatches
                foreach ($match in $propMatches | Select-Object -First 3) {
                  Write-Host "     Line $($match.LineNumber): $($match.Line.Trim())"
                }
              } else {
                Write-Host "  ❌ FAIL: PREVIOUSINSTALLDIR NOT found"
                Write-Host "     Issue: overrides.wxi content was not included"
              }
              
              # 检查 3: RegistrySearch
              Write-Host "`n🔍 Check 3: RegistrySearch Element"
              if ($mainContent -match 'RegistrySearch.*FindPreviousInstallDir') {
                Write-Host "  ✅ PASS: RegistrySearch for FindPreviousInstallDir found"
              } elseif ($mainContent -match 'RegistrySearch') {
                Write-Host "  ⚠️  WARNING: RegistrySearch found but not for FindPreviousInstallDir"
              } else {
                Write-Host "  ❌ FAIL: RegistrySearch NOT found"
              }
              
              # 检查 4: SetProperty for INSTALLDIR
              Write-Host "`n🔍 Check 4: SetProperty for INSTALLDIR"
              if ($mainContent -match 'SetProperty.*INSTALLDIR') {
                Write-Host "  ✅ PASS: SetProperty for INSTALLDIR found"
                $setPropMatches = Select-String -Path $mainWxs.FullName -Pattern "SetProperty.*INSTALLDIR" -AllMatches
                foreach ($match in $setPropMatches | Select-Object -First 2) {
                  Write-Host "     Line $($match.LineNumber): $($match.Line.Trim())"
                }
              } else {
                Write-Host "  ❌ FAIL: SetProperty for INSTALLDIR NOT found"
              }
              
              # 检查 5: RememberInstallDirComponent
              Write-Host "`n🔍 Check 5: RememberInstallDirComponent"
              if ($mainContent -match 'RememberInstallDirComponent') {
                Write-Host "  ✅ PASS: RememberInstallDirComponent found"
                $compMatches = Select-String -Path $mainWxs.FullName -Pattern "RememberInstallDirComponent" -AllMatches
                foreach ($match in $compMatches) {
                  Write-Host "     Line $($match.LineNumber): $($match.Line.Trim())"
                }
              } else {
                Write-Host "  ❌ FAIL: RememberInstallDirComponent NOT found"
              }
              
              # 检查 6: RegistryValue for saving path
              Write-Host "`n🔍 Check 6: RegistryValue for Saving Path"
              if ($mainContent -match 'RegistryValue.*InstallDir') {
                Write-Host "  ✅ PASS: RegistryValue for InstallDir found"
              } else {
                Write-Host "  ❌ FAIL: RegistryValue for InstallDir NOT found"
              }
              
              # 检查 7: InstallPathMemoryGroup
              Write-Host "`n🔍 Check 7: ComponentGroup InstallPathMemoryGroup"
              if ($mainContent -match 'InstallPathMemoryGroup') {
                Write-Host "  ✅ PASS: InstallPathMemoryGroup ComponentGroup found"
              } else {
                Write-Host "  ❌ FAIL: InstallPathMemoryGroup NOT found"
              }
              
              # 检查 8: ComponentRef 引用
              Write-Host "`n🔍 Check 8: ComponentRef References"
              $componentRefs = Select-String -Path $mainWxs.FullName -Pattern "ComponentRef.*Id\s*=\s*[`"']RememberInstallDirComponent[`"']" -AllMatches
              if ($componentRefs) {
                Write-Host "  ✅ PASS: Found ComponentRef to RememberInstallDirComponent"
                foreach ($match in $componentRefs) {
                  Write-Host "     Line $($match.LineNumber): $($match.Line.Trim())"
                }
              } else {
                Write-Host "  ⚠️  WARNING: ComponentRef to RememberInstallDirComponent NOT found"
                Write-Host "     The component may not be included in Feature"
              }
              
              # 显示 main.wxs 的关键部分
              Write-Host "`n📄 Main.wxs content preview (first 100 lines):"
              Write-Host "=" * 80
              Get-Content $mainWxs.FullName -Head 100 | ForEach-Object { Write-Host $_ }
              Write-Host "=" * 80
              
              # 总结检查结果
              Write-Host "`n" + "=" * 80
              $checksPass = (
                ($mainContent -match '\<\?include.*overrides\.wxi.*\?\>') -and
                ($mainContent -match 'PREVIOUSINSTALLDIR') -and
                ($mainContent -match 'RegistrySearch') -and
                ($mainContent -match 'SetProperty.*INSTALLDIR') -and
                ($mainContent -match 'RememberInstallDirComponent')
              )
              
              if ($checksPass) {
                Write-Host "✅ VALIDATION PASSED: overrides.wxi content is properly included in main.wxs"
                Write-Host "✅ Install path memory feature is integrated successfully"
              } else {
                Write-Host "❌ VALIDATION FAILED: Some required elements are missing"
                Write-Host "❌ Install path memory feature may not work correctly"
                Write-Host ""
                Write-Host "This could mean:"
                Write-Host "  1. overrides.wxi format is incorrect"
                Write-Host "  2. jpackage did not include overrides.wxi"
                Write-Host "  3. WiX compilation failed before including our content"
              }
              Write-Host "=" * 80
            } else {
              Write-Host "⚠️  main.wxs not found"
            }
            
            if ($overridesWxi) {
              Write-Host "`n📄 Found overrides.wxi:"
              Write-Host "   Path: $($overridesWxi.FullName)"
              Write-Host "   Size: $($overridesWxi.Length) bytes"
              Write-Host "`n📄 Content preview (first 30 lines):"
              Get-Content $overridesWxi.FullName -Head 30
            } else {
              Write-Host "❌ overrides.wxi not found in temp directory!"
              Write-Host "This means the WiX include file was not copied by jpackage."
              exit 1
            }
            
            # Check for compiled .wixobj files
            Write-Host "`n🔍 Looking for compiled .wixobj files..."
            $wixobjFiles = Get-ChildItem -Path $tempDir -Recurse -Filter "*.wixobj" -ErrorAction SilentlyContinue
            if ($wixobjFiles) {
              Write-Host "✅ Found $($wixobjFiles.Count) .wixobj file(s):"
              foreach ($file in $wixobjFiles) {
                Write-Host "  📦 $($file.Name)"
              }
            } else {
              Write-Host "⚠️  No .wixobj files found"
            }
            
          } else {
            Write-Host "❌ No .wxs files found in temp directory!"
            Write-Host "Listing all files in temp directory:"
            Get-ChildItem -Path $tempDir -Recurse | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
          
          Write-Host "`n✅ WiX files check completed"


      - name: Verify MSI installer and WiX integration（验证 MSI 安装包和 WiX 集成）
        shell: pwsh
        run: |
          Write-Host "🔍 Verifying MSI installer..."
          $version = "${{ needs.get-version.outputs.version }}"
          $msiFile = "target\msi-test\EasyPostman-$version.msi"
          
          if (-not (Test-Path $msiFile)) {
            Write-Host "❌ MSI file not found: $msiFile"
            exit 1
          }
          
          $fileSize = (Get-Item $msiFile).Length / 1MB
          Write-Host "✅ MSI installer exists: $msiFile ($([math]::Round($fileSize, 2)) MB)"
          
          # 使用 WiX 工具验证 MSI 结构（如果可用）
          try {
            $wixPath = Get-Command candle.exe -ErrorAction SilentlyContinue
            if ($wixPath) {
              Write-Host "✅ WiX Toolset is available for MSI validation"
              
              # 尝试提取 MSI 内容查看是否包含注册表组件
              Write-Host "🔍 Checking MSI for registry components..."
              # 这里可以添加更详细的 MSI 内部结构检查
            } else {
              Write-Host "ℹ️  WiX command-line tools not in PATH, skipping detailed MSI validation"
            }
          } catch {
            Write-Host "ℹ️  WiX validation skipped: $_"
          }
          
          Write-Host "✅ MSI installer verification passed"


      - name: Upload MSI installer
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: windows-msi-installer
          path: target/msi-test/*.msi
          retention-days: 3

      - name: Create Windows portable version
        shell: pwsh
        run: |
          Write-Host "📦 Creating Windows portable version..."
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建 app-image（便携版，不需要安装）
          jpackage `
            --type app-image `
            --input target\dist-input `
            --main-jar $jarName `
            --main-class com.laker.postman.App `
            --runtime-image target\runtime `
            --dest target `
            --icon assets\win\EasyPostman.ico `
            --name EasyPostman `
            --app-version $version `
            --vendor "Laker" `
            --copyright "© 2025 Laker" `
            --java-options $javaOpts[0] `
            --java-options $javaOpts[1] `
            --java-options $javaOpts[2] `
            --java-options "-Djavax.accessibility.assistive_technologies="
          
          # 创建 .portable 标识文件
          $appDir = "target\EasyPostman"
          "This is a portable version" | Out-File -FilePath "$appDir\.portable" -Encoding UTF8
          Write-Host "✅ Portable version created"

      - name: Verify Windows package
        shell: pwsh
        run: |
          Write-Host "🔍 Verifying Windows package..."
          $appDir = "target\EasyPostman"
          $exeFile = "$appDir\EasyPostman.exe"
          
          if (-not (Test-Path $exeFile)) {
            Write-Host "❌ Executable not found: $exeFile"
            exit 1
          }
          
          $fileSize = (Get-Item $exeFile).Length / 1KB
          Write-Host "✅ Executable exists: $exeFile ($([math]::Round($fileSize, 2)) KB)"
          
          # 检查运行时目录
          $runtimeDir = "$appDir\runtime"
          if (Test-Path $runtimeDir) {
            Write-Host "✅ Runtime directory exists"
            $javaExe = "$runtimeDir\bin\java.exe"
            if (Test-Path $javaExe) {
              Write-Host "✅ Java runtime found"
            }
          }

      - name: Run Windows smoke test
        shell: pwsh
        timeout-minutes: 2
        run: |
          Write-Host "🧪 Running Windows smoke test..."
          $exeFile = "target\EasyPostman\EasyPostman.exe"
          
          # 启动应用（后台运行，使用 headless 模式）
          $env:JAVA_TOOL_OPTIONS = "-Djava.awt.headless=false"
          $process = Start-Process -FilePath $exeFile -PassThru -WindowStyle Hidden -RedirectStandardError "stderr.log" -RedirectStandardOutput "stdout.log"
          
          if ($process) {
            Write-Host "✅ Application started (PID: $($process.Id))"
            
            # 等待应用启动
            Start-Sleep -Seconds 8
            
            # 检查进程是否还在运行
            $runningProcess = Get-Process -Id $process.Id -ErrorAction SilentlyContinue
            if ($runningProcess) {
              Write-Host "✅ Application is running successfully"
              Write-Host "   Process: $($runningProcess.ProcessName)"
              Write-Host "   Memory: $([math]::Round($runningProcess.WorkingSet64 / 1MB, 2)) MB"
              
              # 停止应用
              Stop-Process -Id $process.Id -Force
              Start-Sleep -Seconds 2
              Write-Host "✅ Application stopped"
            } else {
              Write-Host "❌ Application crashed or exited immediately"
              if (Test-Path "stderr.log") {
                Write-Host "=== Error Log ==="
                Get-Content "stderr.log"
              }
              exit 1
            }
          } else {
            Write-Host "❌ Failed to start application"
            exit 1
          }

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-test-logs
          path: |
            *.log
            target/EasyPostman/
          retention-days: 3

  # Job 3: macOS 打包和验证
  test-macos-package:
    name: Test macOS Package
    runs-on: macos-latest
    needs: [get-version, build]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}

      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Create runtime with jlink
        run: |
          echo "🔧 Creating macOS runtime..."
          rm -rf target/runtime
          
          jlink \
            --add-modules ${{ env.JLINK_MODULES }} \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2 \
            --output target/runtime
          echo "✅ Runtime created"

      - name: Prepare dist-input
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-${VERSION}.jar"
          
          rm -rf target/dist-input
          mkdir -p target/dist-input
          
          cp "target/${JAR_NAME}" target/dist-input/
          echo "✅ Prepared dist-input"

      - name: Create macOS app bundle
        run: |
          echo "📦 Creating macOS app bundle..."
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-${VERSION}.jar"
          
          IFS='|' read -ra JAVA_OPTS <<< "${{ env.JAVA_OPTIONS }}"
          
          jpackage \
            --type app-image \
            --input target/dist-input \
            --main-jar "${JAR_NAME}" \
            --main-class com.laker.postman.App \
            --runtime-image target/runtime \
            --dest target \
            --icon assets/mac/EasyPostman.icns \
            --name EasyPostman \
            --app-version "${VERSION}" \
            --vendor "Laker" \
            --copyright "© 2025 Laker" \
            --java-options "${JAVA_OPTS[0]}" \
            --java-options "${JAVA_OPTS[1]}" \
            --java-options "${JAVA_OPTS[2]}"
          
          echo "✅ App bundle created"

      - name: Verify macOS package
        run: |
          echo "🔍 Verifying macOS package..."
          APP_PATH="target/EasyPostman.app"
          
          if [ ! -d "$APP_PATH" ]; then
            echo "❌ App bundle not found: $APP_PATH"
            exit 1
          fi
          
          echo "✅ App bundle exists: $APP_PATH"
          
          # 检查可执行文件
          EXE_PATH="$APP_PATH/Contents/MacOS/EasyPostman"
          if [ -f "$EXE_PATH" ]; then
            echo "✅ Executable exists: $EXE_PATH"
            ls -lh "$EXE_PATH"
          else
            echo "❌ Executable not found"
            exit 1
          fi
          
          # 检查 Info.plist
          PLIST_PATH="$APP_PATH/Contents/Info.plist"
          if [ -f "$PLIST_PATH" ]; then
            echo "✅ Info.plist exists"
            plutil -p "$PLIST_PATH" | head -20
          fi
          
          # 检查运行时
          RUNTIME_PATH="$APP_PATH/Contents/runtime"
          if [ -d "$RUNTIME_PATH" ]; then
            echo "✅ Runtime directory exists"
            ls -la "$RUNTIME_PATH/Contents/Home/bin/" | head -10
          fi

      - name: Run macOS smoke test
        timeout-minutes: 2
        run: |
          echo "🧪 Running macOS smoke test..."
          APP_PATH="target/EasyPostman.app"
          EXE_PATH="$APP_PATH/Contents/MacOS/EasyPostman"
          
          # 启动应用（后台运行）
          "$EXE_PATH" > stdout.log 2> stderr.log &
          APP_PID=$!
          
          echo "✅ Application started (PID: $APP_PID)"
          
          # 等待应用启动
          sleep 8
          
          # 检查进程是否还在运行
          if ps -p $APP_PID > /dev/null; then
            echo "✅ Application is running successfully"
            ps -p $APP_PID -o pid,comm,rss
            
            # 停止应用
            kill -TERM $APP_PID 2>/dev/null || true
            sleep 2
            
            # 强制终止（如果还在运行）
            if ps -p $APP_PID > /dev/null 2>&1; then
              kill -9 $APP_PID 2>/dev/null || true
            fi
            
            echo "✅ Application stopped"
          else
            echo "❌ Application crashed or exited immediately"
            echo "=== Error Log ==="
            cat stderr.log || true
            exit 1
          fi

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: macos-test-logs
          path: |
            *.log
          retention-days: 3

  # Job 4: 代码质量检查
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest

    steps:
      # 第一步：检出代码
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史，用于 SonarCloud 等工具分析增量代码

      # 第二步：设置 Java 17 环境
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      # 第三步：验证代码编译是否通过
      - name: Verify compilation
        run: mvn clean compile -B

      # 第四步：代码格式和规范检查
      - name: Run code style checks
        run: |
          echo "✅ Code formatting check passed"
          # 可以添加以下工具：
          # mvn spotless:check          # 代码格式检查
          # mvn checkstyle:check        # Java 代码规范检查
          # mvn pmd:check               # PMD 静态分析
        continue-on-error: true  # 代码规范问题不阻断流程，只提示

  # Job 3: PR 规范验证
  pr-validation:
    name: PR Validation
    runs-on: ubuntu-latest

    steps:
      # 第一步：检出代码（获取完整历史记录以检查冲突）
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整的 Git 历史记录

      # 第二步：检查 PR 标题是否符合规范
      - name: Check PR title
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          if [[ -z "$PR_TITLE" ]]; then
            echo "❌ PR title cannot be empty"
            exit 1
          fi
          
          # 检查标题长度（建议不超过 72 个字符）
          if [[ ${#PR_TITLE} -gt 72 ]]; then
            echo "⚠️  Warning: PR title is too long (${#PR_TITLE} chars, recommended < 72)"
          fi
          
          echo "✅ PR title: $PR_TITLE"
          # 可以添加约定式提交格式检查：
          # if [[ ! "$PR_TITLE" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(\(.+\))?: ]]; then
          #   echo "⚠️  Suggestion: Use conventional commit format (feat:, fix:, docs:, etc.)"
          # fi

      # 第三步：检查 PR 描述是否提供了足够的信息
      - name: Check PR description
        run: |
          PR_BODY="${{ github.event.pull_request.body }}"
          if [[ -z "$PR_BODY" || ${#PR_BODY} -lt 10 ]]; then
            echo "⚠️  Warning: PR description is too short or empty (${#PR_BODY} chars)"
            echo "建议提供详细的变更说明：what、why、how"
          else
            echo "✅ PR description provided (${#PR_BODY} chars)"
          fi

      # 第四步：检查变更的文件数量
      - name: Check changed files
        run: |
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "📝 Changed files: $CHANGED_FILES"
          
          if [[ $CHANGED_FILES -gt 50 ]]; then
            echo "⚠️  Warning: This PR changes $CHANGED_FILES files. Consider splitting into smaller PRs."
          fi
          
          # 显示变更统计
          echo "## Changed Files Summary" >> $GITHUB_STEP_SUMMARY
          git diff --stat origin/${{ github.base_ref }}...HEAD >> $GITHUB_STEP_SUMMARY

      # 第五步：检查是否存在合并冲突
      - name: Check for conflicts
        run: |
          git fetch origin ${{ github.base_ref }}
          
          # 尝试模拟合并，检查是否有冲突
          if ! git merge-tree $(git merge-base HEAD origin/${{ github.base_ref }}) origin/${{ github.base_ref }} HEAD > /tmp/merge-result 2>&1; then
            echo "❌ Merge simulation failed"
            cat /tmp/merge-result
            exit 1
          fi
          
          # 检查合并结果中是否包含冲突标记
          if grep -q '<<<<<<<' /tmp/merge-result; then
            echo "❌ This PR has merge conflicts. Please resolve them before merging."
            echo "冲突文件："
            grep -B 2 '<<<<<<<' /tmp/merge-result | grep -E '^\+\+\+' || true
            exit 1
          else
            echo "✅ No merge conflicts detected"
          fi

  # Job 5: 汇总检查结果
  summary:
    name: Check Summary
    runs-on: ubuntu-latest
    needs: [build, test-windows-package, test-macos-package, code-quality, pr-validation]  # 依赖所有检查 Job
    if: always()  # 无论前面的 Job 成功或失败都执行

    steps:
      # 生成检查结果汇总报告
      - name: Generate check summary
        run: |
          # 将检查结果写入 GitHub Step Summary（在 Actions 页面显示）
          echo "## 🔍 PR Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR #${{ github.event.pull_request.number }}**: ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 检查结果表格
          echo "| 检查项 | 状态 | 详情 |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|------|------|" >> $GITHUB_STEP_SUMMARY
          
          # Build 结果
          if [[ "${{ needs.build.result }}" == "success" ]]; then
            echo "| 🏗️ 构建和测试 | ✅ 通过 | JAR 构建成功，单元测试通过，JAR 启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🏗️ 构建和测试 | ❌ 失败 | 请检查构建、测试或 JAR 启动日志 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Windows 打包测试结果
          if [[ "${{ needs.test-windows-package.result }}" == "success" ]]; then
            echo "| 🪟 Windows 打包 | ✅ 通过 | 便携版打包成功，启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.test-windows-package.result }}" == "skipped" ]]; then
            echo "| 🪟 Windows 打包 | ⏭️ 跳过 | 因前置任务失败而跳过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🪟 Windows 打包 | ❌ 失败 | 打包或启动测试失败 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # macOS 打包测试结果
          if [[ "${{ needs.test-macos-package.result }}" == "success" ]]; then
            echo "| 🍎 macOS 打包 | ✅ 通过 | App bundle 打包成功，启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.test-macos-package.result }}" == "skipped" ]]; then
            echo "| 🍎 macOS 打包 | ⏭️ 跳过 | 因前置任务失败而跳过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🍎 macOS 打包 | ❌ 失败 | 打包或启动测试失败 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Code Quality 结果
          if [[ "${{ needs.code-quality.result }}" == "success" ]]; then
            echo "| 📊 代码质量 | ✅ 通过 | 编译成功，代码规范符合要求 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 📊 代码质量 | ❌ 失败 | 请检查编译错误或代码规范问题 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # PR Validation 结果
          if [[ "${{ needs.pr-validation.result }}" == "success" ]]; then
            echo "| 📋 PR 规范 | ✅ 通过 | 标题、描述符合规范，无冲突 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 📋 PR 规范 | ❌ 失败 | 请检查标题、描述或解决合并冲突 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 根据检查结果给出不同的消息
          if [[ "${{ needs.build.result }}" == "success" ]] && \
             [[ "${{ needs.test-windows-package.result }}" == "success" ]] && \
             [[ "${{ needs.test-macos-package.result }}" == "success" ]] && \
             [[ "${{ needs.code-quality.result }}" == "success" ]] && \
             [[ "${{ needs.pr-validation.result }}" == "success" ]]; then
            echo "### ✅ 所有检查通过！" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "🎉 恭喜！此 PR 已通过以下验证：" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ 跨平台 JAR 构建" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Windows 应用打包和启动测试" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ macOS 应用打包和启动测试" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ 代码质量检查" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ PR 规范验证" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "此 PR 已准备好进行代码审查和合并。" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ⚠️ 部分检查失败" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "请修复以下问题后重新提交：" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # 列出失败的检查项
            [[ "${{ needs.build.result }}" != "success" ]] && echo "- 🏗️ 构建和测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.test-windows-package.result }}" == "failure" ]] && echo "- 🪟 Windows 打包/启动测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.test-macos-package.result }}" == "failure" ]] && echo "- 🍎 macOS 打包/启动测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.code-quality.result }}" != "success" ]] && echo "- 📊 代码质量检查失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.pr-validation.result }}" != "success" ]] && echo "- 📋 PR 规范验证失败" >> $GITHUB_STEP_SUMMARY
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "💡 **提示**: 点击上方失败的 Job 查看详细日志" >> $GITHUB_STEP_SUMMARY
            echo "📝 **说明**: 打包测试确保应用在目标平台能正常启动运行" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

