name: Release Build（发布构建）

permissions:
  contents: write

on:
  release:
    types: [created]  # 当创建新的 Release 时触发
  workflow_dispatch: {}  # 支持手动触发

env:
  JAVA_VERSION: '17'
  JAVA_DISTRIBUTION: 'temurin'
  JLINK_MODULES: 'java.base,java.desktop,java.logging,jdk.unsupported,java.naming,java.net.http,java.prefs,java.sql,java.security.sasl,java.security.jgss,jdk.crypto.ec,java.management,java.management.rmi,jdk.crypto.cryptoki'
  JAVA_OPTIONS: '-Xms256m|-Xmx512m|-Dfile.encoding=UTF-8'

jobs:
  # 提取版本号，供所有 job 复用
  get-version:
    name: Get Version（获取版本号）
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract_version.outputs.version }}
    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Extract version（提取版本号）
        id: extract_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # 构建 Fat JAR（跨平台），供所有平台复用
  build-jar-artifact:
    name: Build Fat JAR（构建跨平台 JAR）
    runs-on: ubuntu-latest
    needs: [get-version]
    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}
          cache: 'maven'

      - name: Build with Maven（使用 Maven 构建 Fat JAR）
        run: mvn -B clean package -DskipTests

      - name: Upload JAR for reuse（上传 JAR 供其他 job 复用）
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/easy-postman-${{ needs.get-version.outputs.version }}.jar
          retention-days: 1

  build-windows:
    name: Build Windows MSI（构建 Windows 安装包）
    runs-on: windows-latest
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}

      - name: Download Fat JAR（下载跨平台 Fat JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Install WiX (for jpackage)（安装 WiX 工具集，用于创建 MSI）
        shell: pwsh
        run: |
          choco install wixtoolset -y
          if (Get-Command refreshenv -ErrorAction SilentlyContinue) { 
            refreshenv 
          } else {
            $refreshScript = "$env:ChocolateyInstall\lib\refreshenv\tools\RefreshEnv.ps1"
            if (Test-Path $refreshScript) { & $refreshScript }
          }

      - name: Create runtime with jlink（使用 jlink 创建 Windows 精简 JRE）
        shell: pwsh
        run: |
          $runtimeDir = "target\runtime"
          if (Test-Path $runtimeDir) { Remove-Item -Recurse -Force $runtimeDir }
          
          # 创建 Windows 平台的 JRE
          jlink `
            --add-modules $env:JLINK_MODULES `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2 `
            --output $runtimeDir

      - name: Prepare dist-input（准备打包输入目录）
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $distInputDir = "target\dist-input"
          if (Test-Path $distInputDir) { Remove-Item -Recurse -Force $distInputDir }
          New-Item -ItemType Directory -Path $distInputDir | Out-Null
          
          Copy-Item "target\$jarName" -Destination $distInputDir

      - name: Copy WiX configuration to remember installation path（复制 WiX 配置以记住安装路径）
        shell: pwsh
        run: |
          $resourceDir = "target\jpackage-resources"
          if (-not (Test-Path $resourceDir)) { New-Item -ItemType Directory -Path $resourceDir | Out-Null }
          
          # 复制 overrides.wxi（jpackage 会自动 include 这个文件）
          # 文件内容：
          # 1. Property + RegistrySearch（读取上次安装路径）
          # 2. SetProperty（设置 INSTALLDIR 初始值）
          # 3. DirectoryRef + Component（定义保存路径的注册表组件）
          # 4. ComponentGroup（将组件包装成组，方便在 Feature 中引用）
          $wixOverrides = "build\overrides.wxi"
          if (-not (Test-Path $wixOverrides)) {
            Write-Host "❌ overrides.wxi not found: $wixOverrides"
            exit 1
          }
          
          Copy-Item $wixOverrides -Destination "$resourceDir\overrides.wxi"
          Write-Host "✅ Copied overrides.wxi (install path memory enabled)"
          Write-Host "   📦 Contains: Property, SetProperty, Component, ComponentGroup"
          Write-Host "   🔗 jpackage will include via: <?include overrides.wxi ?>"
          
          # 验证文件
          if (Test-Path "$resourceDir\overrides.wxi") {
            $fileSize = (Get-Item "$resourceDir\overrides.wxi").Length
            Write-Host "✅ overrides.wxi file size: $fileSize bytes"
            
            # 显示文件内容预览
            Write-Host "`n📄 Content preview:"
            Get-Content "$resourceDir\overrides.wxi" -Head 20 | ForEach-Object { Write-Host "   $_" }
            
            # 检查关键元素
            $content = Get-Content "$resourceDir\overrides.wxi" -Raw
            $hasProperty = $content -match 'PREVIOUSINSTALLDIR'
            $hasComponent = $content -match 'RememberInstallDirComponent'
            $hasGroup = $content -match 'InstallPathMemoryGroup'
            
            Write-Host "`n🔍 Structure validation:"
            Write-Host "   Property 'PREVIOUSINSTALLDIR': $(if ($hasProperty) {'✅'} else {'❌'})"
            Write-Host "   Component 'RememberInstallDirComponent': $(if ($hasComponent) {'✅'} else {'❌'})"
            Write-Host "   ComponentGroup 'InstallPathMemoryGroup': $(if ($hasGroup) {'✅'} else {'❌'})"
            
            if (-not ($hasProperty -and $hasComponent -and $hasGroup)) {
              Write-Host "❌ overrides.wxi is missing required elements"
              exit 1
            }
          } else {
            Write-Host "❌ Failed to copy overrides.wxi"
            exit 1
          }

      - name: Create MSI with jpackage（使用 jpackage 创建 MSI 安装包）
        shell: pwsh
        continue-on-error: true
        id: jpackage_build
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          $outDir = "dist"
          $tempDir = "target\jpackage-temp"
          
          if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }
          
          # 解析 Java 选项
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建 Windows MSI 安装包
          jpackage `
            --type msi `
            --input target\dist-input `
            --main-jar $jarName `
            --main-class com.laker.postman.App `
            --runtime-image target\runtime `
            --dest $outDir `
            --temp $tempDir `
            --icon assets\win\EasyPostman.ico `
            --name EasyPostman `
            --app-version $version `
            --vendor "Laker" `
            --copyright "© 2025 Laker" `
            --win-shortcut `
            --win-menu `
            --description "A modern API testing tool similar to Postman" `
            --win-upgrade-uuid "28607609-97b7-4212-9285-04ef64a4946c" `
            --win-dir-chooser `
            --win-per-user-install `
            --win-menu-group "EasyTools" `
            --win-help-url "https://gitee.com/lakernote/easy-postman" `
            --resource-dir "target\jpackage-resources" `
            --java-options $javaOpts[0] `
            --java-options $javaOpts[1] `
            --java-options $javaOpts[2] `
            --java-options "-Djavax.accessibility.assistive_technologies="
          
          $jpackageExitCode = $LASTEXITCODE
          Write-Host "jpackage exit code: $jpackageExitCode"
          
          # Check if MSI was created
          $oldMsiName = "EasyPostman-$version.msi"
          if (Test-Path "dist\$oldMsiName") {
            # 重命名添加平台和架构标识（符合命名规范）
            $newMsiName = "EasyPostman-$version-windows-x64.msi"
            Rename-Item -Path "dist\$oldMsiName" -NewName $newMsiName
            Write-Host "✅ Renamed to: $newMsiName"
            exit 0
          } else {
            Write-Host "⚠️  MSI not created, will attempt manual build"
            exit 1
          }

      - name: Debug - Inspect jpackage temp directory（调试 - 检查 jpackage 临时目录）
        if: steps.jpackage_build.outcome == 'failure'
        shell: pwsh
        run: |
          Write-Host "🔍 Checking WiX files in jpackage temp directory..."
          
          $tempDir = "target\jpackage-temp"
          
          if (Test-Path $tempDir) {
            Write-Host "📂 Temp directory exists: $tempDir"
            
            Write-Host "`n🔍 Looking for .wxs and .wxi files..."
            $wixFiles = Get-ChildItem $tempDir -Recurse -Include "*.wxs","*.wxi"
            
            if ($wixFiles.Count -gt 0) {
              Write-Host "✅ Found $($wixFiles.Count) WiX file(s):"
              foreach ($file in $wixFiles) {
                Write-Host "   📄 $($file.FullName) ($($file.Length) bytes)"
              }
              
              # 检查 main.wxs
              $mainWxs = Get-ChildItem $tempDir -Recurse -Filter "main.wxs" | Select-Object -First 1
              if ($mainWxs) {
                Write-Host "`n📄 Found main.wxs:"
                Write-Host "   Path: $($mainWxs.FullName)"
                Write-Host "   Size: $($mainWxs.Length) bytes"
                
                Write-Host "`n📄 Content preview (first 60 lines):"
                Get-Content $mainWxs.FullName -Head 60 | ForEach-Object { Write-Host $_ }
                
                Write-Host "`n🔍 Checking for overrides.wxi include:"
                $includeCheck = Select-String -Path $mainWxs.FullName -Pattern "overrides.wxi" -AllMatches
                if ($includeCheck) {
                  Write-Host "   ✅ overrides.wxi is included in main.wxs"
                  $includeCheck | ForEach-Object { Write-Host "      $_" }
                } else {
                  Write-Host "   ⚠️  overrides.wxi include not found in main.wxs"
                }
                
                Write-Host "`n🔍 Checking for our custom Property definitions:"
                $propertyCheck = Select-String -Path $mainWxs.FullName -Pattern "PREVIOUSINSTALLDIR|RememberInstallDirComponent" -AllMatches
                if ($propertyCheck) {
                  Write-Host "   ✅ Custom Property/Component found in main.wxs:"
                  $propertyCheck | ForEach-Object { Write-Host "      $_" }
                } else {
                  Write-Host "   ⚠️  Custom Property/Component not found (may be in overrides.wxi)"
                }
                
                Write-Host "`n🔍 Searching for Feature section:"
                $featureCheck = Select-String -Path $mainWxs.FullName -Pattern "<Feature|</Feature>|ComponentRef" -AllMatches
                if ($featureCheck) {
                  Write-Host "   ✅ Feature section found:"
                  $featureCheck | Select-Object -First 10 | ForEach-Object { Write-Host "      $_" }
                } else {
                  Write-Host "   ⚠️  No Feature section found in main.wxs"
                }
              }
              
              # 检查 overrides.wxi
              $overridesWxi = Get-ChildItem $tempDir -Recurse -Filter "overrides.wxi" | Select-Object -First 1
              if ($overridesWxi) {
                Write-Host "`n📄 Found overrides.wxi:"
                Write-Host "   Path: $($overridesWxi.FullName)"
                Write-Host "   Size: $($overridesWxi.Length) bytes"
                Write-Host "`n   Content:"
                Get-Content $overridesWxi.FullName | ForEach-Object { Write-Host "   $_" }
              } else {
                Write-Host "`n❌ overrides.wxi not found in temp directory!"
              }
            } else {
              Write-Host "❌ No WiX files found in temp directory"
            }
          } else {
            Write-Host "❌ Temp directory does not exist: $tempDir"
          }

      - name: Manual build - Patch and compile WiX files（手动构建 - 修补并编译 WiX 文件）
        if: steps.jpackage_build.outcome == 'failure'
        shell: pwsh
        run: |
          Write-Host "🔧 Attempting manual WiX build..."
          Write-Host ""
          Write-Host "ℹ️  Background: Why manual patching is needed?"
          Write-Host "   1. overrides.wxi defines Component and ComponentGroup"
          Write-Host "   2. jpackage includes overrides.wxi in main.wxs"
          Write-Host "   3. BUT: Components must be referenced in <Feature> to be installed"
          Write-Host "   4. We need to add: <ComponentGroupRef Id='InstallPathMemoryGroup' />"
          Write-Host ""
          $version = "${{ needs.get-version.outputs.version }}"
          $configDir = "target\jpackage-temp\config"
          $mainWxsPath = "$configDir\main.wxs"
          
          # 检查 config 目录是否存在
          if (-not (Test-Path $configDir)) {
            Write-Host "❌ Config directory not found. jpackage did not generate WiX files."
            exit 1
          }
          
          # 修补 main.wxs 添加 ComponentRef 或 ComponentGroupRef
          if (Test-Path $mainWxsPath) {
            Write-Host "`n📝 Patching main.wxs to add install path memory component..."
            
            $content = Get-Content -Path $mainWxsPath -Raw
            
            # 检查是否已经打过补丁（检查两种引用方式）
            if ($content -match 'RememberInstallDirComponent' -or $content -match 'InstallPathMemoryGroup') {
              Write-Host "✅ main.wxs already contains install path memory component reference"
            } else {
              Write-Host "🔍 Searching for Feature section..."
              
              # 优先尝试使用 ComponentGroupRef（更简洁，推荐方式）
              $pattern = '([\s]+)(</Feature>)'
              $replacement = '$1  <!-- Custom: Install path memory (defined in overrides.wxi) -->' + "`r`n" + 
                           '$1  <ComponentGroupRef Id="InstallPathMemoryGroup" />' + "`r`n" + 
                           '$1$2'
              
              $newContent = $content -replace $pattern, $replacement
              
              if ($newContent -ne $content) {
                $newContent | Set-Content -Path $mainWxsPath -NoNewline
                Write-Host "✅ Successfully added ComponentGroupRef to Feature section"
                Write-Host "   <ComponentGroupRef Id='InstallPathMemoryGroup' />"
              } else {
                Write-Host "⚠️  Could not find </Feature> tag to patch"
                Write-Host "🔍 Trying alternative pattern..."
                
                # 备用方案：尝试查找 Feature 的其他模式
                $pattern2 = '(<Feature[^>]*>)(.*?)(</Feature>)'
                if ($content -match $pattern2) {
                  Write-Host "✅ Found Feature with alternative pattern"
                  # 使用直接的 ComponentRef
                  $pattern3 = '([\s]+)(</Feature>)'
                  $replacement3 = '$1  <!-- Custom: Install path memory component -->' + "`r`n" + 
                                '$1  <ComponentRef Id="RememberInstallDirComponent" />' + "`r`n" + 
                                '$1$2'
                  $newContent = $content -replace $pattern3, $replacement3
                  if ($newContent -ne $content) {
                    $newContent | Set-Content -Path $mainWxsPath -NoNewline
                    Write-Host "✅ Added ComponentRef (fallback method)"
                  } else {
                    Write-Host "❌ Failed to patch main.wxs"
                    Write-Host "🔍 Dumping main.wxs structure for debugging..."
                    Write-Host ($content -split "`n" | Select-Object -First 60 | Out-String)
                    exit 1
                  }
                } else {
                  Write-Host "❌ No Feature section found in main.wxs"
                  Write-Host "🔍 Dumping main.wxs structure for debugging..."
                  Write-Host ($content -split "`n" | Select-Object -First 60 | Out-String)
                  exit 1
                }
              }
            }
          } else {
            Write-Host "❌ main.wxs not found at: $mainWxsPath"
            exit 1
          }
          
          # 查找 WiX Toolset
          Write-Host "`n🔍 Locating WiX Toolset..."
          $wixPath = "${env:ProgramFiles(x86)}\WiX Toolset v3.11\bin"
          if (-not (Test-Path $wixPath)) {
            $wixPath = "${env:ProgramFiles}\WiX Toolset v3.11\bin"
          }
          if (-not (Test-Path $wixPath)) {
            Write-Host "❌ WiX Toolset not found"
            exit 1
          }
          
          Write-Host "✅ Found WiX at: $wixPath"
          
          # 编译 WiX 源文件
          Write-Host "`n🔨 Compiling WiX sources..."
          $wixSources = Get-ChildItem $configDir -Filter "*.wxs"
          Write-Host "   Found $($wixSources.Count) .wxs file(s)"
          
          foreach ($wxs in $wixSources) {
            $objFile = Join-Path $configDir "$($wxs.BaseName).wixobj"
            Write-Host "   📄 Compiling $($wxs.Name)..."
            
            & "$wixPath\candle.exe" -nologo -arch x64 -out $objFile $wxs.FullName
            
            if ($LASTEXITCODE -ne 0) {
              Write-Host "❌ Failed to compile $($wxs.Name)"
              exit 1
            }
          }
          
          Write-Host "✅ All WiX sources compiled successfully"
          
          # 链接生成 MSI
          Write-Host "`n🔗 Linking WiX objects to create MSI..."
          $wixObjs = Get-ChildItem $configDir -Filter "*.wixobj" | ForEach-Object { $_.FullName }
          Write-Host "   Found $($wixObjs.Count) .wixobj file(s)"
          
          $msiOutput = "dist\EasyPostman-$version.msi"
          
          & "$wixPath\light.exe" -nologo -ext WixUIExtension -ext WixUtilExtension -out $msiOutput @wixObjs
          
          if ($LASTEXITCODE -ne 0) {
            Write-Host "❌ Failed to link MSI"
            exit 1
          }
          
          Write-Host "✅ MSI created successfully: $msiOutput"
          
          # 重命名为平台特定文件名
          $newMsiName = "EasyPostman-$version-windows-x64.msi"
          Rename-Item -Path $msiOutput -NewName $newMsiName
          Write-Host "✅ Renamed to: $newMsiName"

      - name: Verify MSI was created（验证 MSI 已创建）
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $msiFile = "dist\EasyPostman-$version-windows-x64.msi"
          
          if (Test-Path $msiFile) {
            $size = (Get-Item $msiFile).Length
            $sizeMB = [math]::Round($size / 1MB, 2)
            Write-Host "✅ MSI created successfully: $msiFile ($sizeMB MB)"
          } else {
            Write-Host "❌ MSI file not found: $msiFile"
            Write-Host "📂 Contents of dist directory:"
            Get-ChildItem dist -Recurse | ForEach-Object { Write-Host "   $($_.FullName)" }
            exit 1
          }

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'  # 只在 Release 触发时上传
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.msi
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'  # 只在手动触发时上传为 Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-Windows-MSI
          path: dist/*.msi
          retention-days: 7  # 保留 7 天

      - name: Upload MSI for Gitee sync（上传 MSI 供 Gitee 同步使用）
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-msi
          path: dist/*.msi
          retention-days: 1


  build-windows-portable:
    name: Build Windows Portable（构建 Windows 绿色版）
    runs-on: windows-latest
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}

      - name: Download Fat JAR（下载跨平台 Fat JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Create runtime with jlink（使用 jlink 创建 Windows 精简 JRE）
        shell: pwsh
        run: |
          $runtimeDir = "target\runtime"
          if (Test-Path $runtimeDir) { Remove-Item -Recurse -Force $runtimeDir }
          
          jlink `
            --add-modules $env:JLINK_MODULES `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2 `
            --output $runtimeDir

      - name: Prepare dist-input（准备打包输入目录）
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $distInputDir = "target\dist-input"
          if (Test-Path $distInputDir) { Remove-Item -Recurse -Force $distInputDir }
          New-Item -ItemType Directory -Path $distInputDir | Out-Null
          
          Copy-Item "target\$jarName" -Destination $distInputDir

      - name: Create app-image with jpackage（创建应用镜像，免安装）
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          $appImageDir = "target\app-image"
          
          if (Test-Path $appImageDir) { Remove-Item -Recurse -Force $appImageDir }
          
          # 解析 Java 选项
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建应用镜像（app-image 类型，不是安装包）
          jpackage `
            --type app-image `
            --input target\dist-input `
            --main-jar $jarName `
            --main-class com.laker.postman.App `
            --runtime-image target\runtime `
            --dest target `
            --icon assets\win\EasyPostman.ico `
            --name EasyPostman `
            --app-version $version `
            --vendor "Laker" `
            --copyright "© 2025 Laker" `
            --java-options $javaOpts[0] `
            --java-options $javaOpts[1] `
            --java-options $javaOpts[2] `
            --java-options "-Djavax.accessibility.assistive_technologies="

      - name: Package portable version（打包绿色版为 ZIP）
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $appImageDir = "target\EasyPostman"
          $zipName = "EasyPostman-$version-windows-x64-portable.zip"
          
          if (-not (Test-Path "dist")) { New-Item -ItemType Directory -Path "dist" | Out-Null }
          
          # 创建 .portable 标识文件，用于运行时检测便携版
          $portableMarker = Join-Path $appImageDir ".portable"
          "This is a portable version" | Out-File -FilePath $portableMarker -Encoding UTF8
          Write-Host "Created .portable marker file"
          
          # 压缩为 ZIP
          Compress-Archive -Path $appImageDir -DestinationPath "dist\$zipName" -Force
          
          Write-Host "✅ Created portable version: $zipName"

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*-portable.zip
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-Windows-Portable
          path: dist/*-portable.zip
          retention-days: 7

      - name: Upload Portable ZIP for Gitee sync（上传便携版 ZIP 供 Gitee 同步使用）
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-portable-zip
          path: dist/*-portable.zip
          retention-days: 1

  build-macos-intel:
    name: Build macOS Intel DMG（构建 macOS Intel 版安装包）
    runs-on: macos-13  # Intel x86_64
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}

      - name: Download Fat JAR（下载跨平台 Fat JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Create runtime with jlink（使用 jlink 创建 macOS Intel 精简 JRE）
        run: |
          rm -rf target/runtime
          # 创建 macOS Intel 平台的 JRE
          jlink \
            --add-modules ${{ env.JLINK_MODULES }} \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2 \
            --output target/runtime

      - name: Prepare dist-input（准备打包输入目录）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          rm -rf target/dist-input
          mkdir -p target/dist-input
          cp target/$JAR_NAME target/dist-input/

      - name: Create DMG with jpackage（使用 jpackage 创建 DMG 镜像）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          mkdir -p dist
          
          # 解析 Java 选项
          IFS='|' read -ra JAVA_OPTS <<< "${{ env.JAVA_OPTIONS }}"
          
          # 创建 macOS Intel DMG
          jpackage \
            --input target/dist-input \
            --main-jar $JAR_NAME \
            --main-class com.laker.postman.App \
            --runtime-image target/runtime \
            --type dmg \
            --name "EasyPostman" \
            --app-version "$VERSION" \
            --dest dist \
            --icon assets/mac/EasyPostman.icns \
            --vendor "Laker" \
            --copyright "© 2025 Laker" \
            --java-options "${JAVA_OPTS[0]}" \
            --java-options "${JAVA_OPTS[1]}" \
            --java-options "${JAVA_OPTS[2]}"
          
          # 重命名为 Intel 版本（使用标准架构标识）
          mv dist/EasyPostman-$VERSION.dmg dist/EasyPostman-$VERSION-macos-x86_64.dmg
          echo "✅ Created: EasyPostman-$VERSION-macos-x86_64.dmg"

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'  # 只在 Release 触发时上传
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*-macos-x86_64.dmg
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'  # 只在手动触发时上传为 Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-macOS-Intel-DMG
          path: dist/*-macos-x86_64.dmg
          retention-days: 7  # 保留 7 天

      - name: Upload DMG for Gitee sync（上传 DMG 供 Gitee 同步使用）
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-dmg-intel
          path: dist/*-macos-x86_64.dmg
          retention-days: 1

  build-macos-arm:
    name: Build macOS Apple Silicon DMG（构建 macOS Apple Silicon 版安装包）
    runs-on: macos-latest  # Apple Silicon (M1/M2/M3/M4)
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}

      - name: Download Fat JAR（下载跨平台 Fat JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Create runtime with jlink（使用 jlink 创建 macOS ARM 精简 JRE）
        run: |
          rm -rf target/runtime
          # 创建 macOS ARM 平台的 JRE
          jlink \
            --add-modules ${{ env.JLINK_MODULES }} \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2 \
            --output target/runtime

      - name: Prepare dist-input（准备打包输入目录）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          rm -rf target/dist-input
          mkdir -p target/dist-input
          cp target/$JAR_NAME target/dist-input/

      - name: Create DMG with jpackage（使用 jpackage 创建 DMG 镜像）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          mkdir -p dist
          
          # 解析 Java 选项
          IFS='|' read -ra JAVA_OPTS <<< "${{ env.JAVA_OPTIONS }}"
          
          # 创建 macOS Apple Silicon DMG
          jpackage \
            --input target/dist-input \
            --main-jar $JAR_NAME \
            --main-class com.laker.postman.App \
            --runtime-image target/runtime \
            --type dmg \
            --name "EasyPostman" \
            --app-version "$VERSION" \
            --dest dist \
            --icon assets/mac/EasyPostman.icns \
            --vendor "Laker" \
            --copyright "© 2025 Laker" \
            --java-options "${JAVA_OPTS[0]}" \
            --java-options "${JAVA_OPTS[1]}" \
            --java-options "${JAVA_OPTS[2]}"
          
          # 重命名为 ARM 版本（使用标准架构标识）
          mv dist/EasyPostman-$VERSION.dmg dist/EasyPostman-$VERSION-macos-arm64.dmg
          echo "✅ Created: EasyPostman-$VERSION-macos-arm64.dmg"

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'  # 只在 Release 触发时上传
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*-macos-arm64.dmg
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'  # 只在手动触发时上传为 Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-macOS-ARM-DMG
          path: dist/*-macos-arm64.dmg
          retention-days: 7  # 保留 7 天

      - name: Upload DMG for Gitee sync（上传 DMG 供 Gitee 同步使用）
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-dmg-arm64
          path: dist/*-macos-arm64.dmg
          retention-days: 1

  build-jar:
    name: Build Standalone JAR（构建独立 JAR 包）
    runs-on: ubuntu-latest
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Download JAR artifact（下载已构建的 JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: dist

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.jar
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-Standalone-JAR
          path: dist/*.jar
          retention-days: 7


  build-ubuntu:
    name: Build Ubuntu DEB（构建 Ubuntu 安装包）
    runs-on: ubuntu-22.04
    needs: [get-version, build-jar-artifact]

    steps:
      - name: Checkout（检出代码）
        uses: actions/checkout@v4

      - name: Setup Java（配置 Java）
        uses: actions/setup-java@v4
        with:
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          java-version: ${{ env.JAVA_VERSION }}

      - name: Download Fat JAR（下载跨平台 Fat JAR）
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Install dependencies（安装系统依赖）
        run: |
          sudo apt-get update
          # 安装 GTK3、WebKit 和打包工具
          sudo apt-get install -y libgtk-3-dev libwebkit2gtk-4.0-dev binutils

      - name: Create runtime with jlink（使用 jlink 创建 Linux 精简 JRE）
        run: |
          rm -rf target/runtime
          # 创建 Linux 平台的 JRE
          jlink \
            --add-modules ${{ env.JLINK_MODULES }} \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2 \
            --output target/runtime

      - name: Prepare dist-input（准备打包输入目录）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          rm -rf target/dist-input
          mkdir -p target/dist-input
          cp target/$JAR_NAME target/dist-input/

      - name: Create DEB with jpackage（使用 jpackage 创建 DEB 安装包）
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-$VERSION.jar"
          
          mkdir -p dist
          
          # 解析 Java 选项
          IFS='|' read -ra JAVA_OPTS <<< "${{ env.JAVA_OPTIONS }}"
          
          # 创建 Ubuntu/Debian DEB 安装包
          jpackage \
            --input target/dist-input \
            --main-jar $JAR_NAME \
            --main-class com.laker.postman.App \
            --runtime-image target/runtime \
            --type deb \
            --name "EasyPostman" \
            --app-version "$VERSION" \
            --dest dist \
            --vendor "Laker" \
            --copyright "© 2025 Laker" \
            --description "A modern API testing tool similar to Postman" \
            --linux-shortcut \
            --linux-menu-group "Development" \
            --linux-app-category "Development" \
            --java-options "${JAVA_OPTS[0]}" \
            --java-options "${JAVA_OPTS[1]}" \
            --java-options "${JAVA_OPTS[2]}"

      - name: Upload to Release（上传到 GitHub Release）
        if: github.event_name == 'release'  # 只在 Release 触发时上传
        uses: softprops/action-gh-release@v2
        with:
          files: dist/*.deb
          fail_on_unmatched_files: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload as Artifact（手动触发时上传为构建产物）
        if: github.event_name == 'workflow_dispatch'  # 只在手动触发时上传为 Artifact
        uses: actions/upload-artifact@v4
        with:
          name: EasyPostman-Ubuntu-DEB
          path: dist/*.deb
          retention-days: 7  # 保留 7 天

      - name: Upload DEB for Gitee sync（上传 DEB 供 Gitee 同步使用）
        if: github.event_name == 'release'
        uses: actions/upload-artifact@v4
        with:
          name: release-deb
          path: dist/*.deb
          retention-days: 1

  # 创建 Gitee Release
  create-gitee-release:
    name: Create Gitee Release（创建 Gitee Release）
    if: github.event_name == 'release'
    needs: [build-windows, build-macos-arm]  # 只等待需要同步到 Gitee 的构建（Windows MSI + macOS ARM）
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.gitee_release.outputs.release_id }}
      tag_name: ${{ steps.get_version.outputs.tag }}

    steps:
      - name: Get version from tag（从标签获取版本号）
        id: get_version
        run: |
          TAG_NAME="${{ github.event.release.tag_name }}"
          VERSION="${TAG_NAME#v}"  # 移除 v 前缀
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=$TAG_NAME" >> $GITHUB_OUTPUT

      - name: Create Gitee Release（创建 Gitee Release）
        id: gitee_release
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          TAG_NAME="${{ steps.get_version.outputs.tag }}"
          RELEASE_BODY="${{ github.event.release.body }}"
          
          if [ -z "$RELEASE_BODY" ]; then
            RELEASE_BODY="EasyPostman ${VERSION} 发布版本，支持 Windows、macOS 和 Linux。详情：https://github.com/lakernote/easy-postman"
          fi
          
          echo "Creating Gitee Release for tag: $TAG_NAME"
          
          curl -s -X POST \
            -F "access_token=${{ secrets.GITEE_TOKEN }}" \
            -F "tag_name=$TAG_NAME" \
            -F "name=$TAG_NAME" \
            -F "body=$RELEASE_BODY" \
            -F "prerelease=false" \
            -F "target_commitish=master" \
            "https://gitee.com/api/v5/repos/lakernote/easy-postman/releases" > /tmp/release.json
          
          echo "API Response:"
          cat /tmp/release.json
          
          # 优先使用 jq（GitHub Actions Ubuntu runner 预装）
          RELEASE_ID=$(jq -r '.id // empty' /tmp/release.json 2>/dev/null || echo "")
          
          if [ -z "$RELEASE_ID" ]; then
            echo "jq extraction failed, trying python3..."
            RELEASE_ID=$(python3 -c "import sys, json; print(json.load(open('/tmp/release.json'))['id'])" 2>/dev/null || echo "")
          fi
          
          if [ -z "$RELEASE_ID" ]; then
            echo "python3 failed, trying grep..."
            RELEASE_ID=$(grep -o '"id":[0-9]*' /tmp/release.json | head -1 | grep -o '[0-9]*')
          fi
          
          if [ -z "$RELEASE_ID" ]; then
            echo "Error: Failed to create release or extract release ID"
            exit 1
          fi
          
          echo "release_id=$RELEASE_ID" >> $GITHUB_OUTPUT
          echo "Gitee Release created successfully with ID: $RELEASE_ID"

  # 并行上传到 Gitee（使用 matrix 策略）
  sync-to-gitee:
    name: Upload ${{ matrix.platform }} to Gitee（上传 ${{ matrix.platform }} 到 Gitee）
    if: github.event_name == 'release'
    needs: [create-gitee-release]  # 等待 Gitee Release 创建完成
    runs-on: ubuntu-latest
    strategy:
      # 不因单个平台失败而取消其他上传任务
      fail-fast: false
      matrix:
        include:
          - platform: 'Windows MSI'
            priority: 1
            artifact_name: 'release-msi'
            file_pattern: '*.msi'
            emoji: '🪟'
          - platform: 'macOS Apple Silicon'
            priority: 2
            artifact_name: 'release-dmg-arm64'
            file_pattern: '*-macos-arm64.dmg'
            emoji: '🍎'

    steps:
      - name: Download ${{ matrix.platform }} artifact（下载 ${{ matrix.platform }} 产物）
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.artifact_name }}
          path: artifacts

      - name: Upload ${{ matrix.platform }} to Gitee（上传 ${{ matrix.platform }} 到 Gitee）
        run: |
          RELEASE_ID="${{ needs.create-gitee-release.outputs.release_id }}"
          FILE=$(find artifacts -name "${{ matrix.file_pattern }}" | head -n 1)
          
          if [ -z "$FILE" ]; then
            echo "⚠️ ${{ matrix.platform }} file not found, skipping..."
            exit 0
          fi
          
          echo "${{ matrix.emoji }} [Priority ${{ matrix.priority }}] Uploading $(basename $FILE) to Gitee..."
          
          # 上传到 Gitee，带重试机制
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -X POST "https://gitee.com/api/v5/repos/lakernote/easy-postman/releases/$RELEASE_ID/attach_files" \
              -F "access_token=${{ secrets.GITEE_TOKEN }}" \
              -F "file=@$FILE"; then
              echo "✅ ${{ matrix.platform }} uploaded successfully!"
              exit 0
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                echo "⚠️ Upload failed, retrying ($RETRY_COUNT/$MAX_RETRIES)..."
                sleep 5
              fi
            fi
          done
          
          echo "❌ Failed to upload ${{ matrix.platform }} after $MAX_RETRIES attempts"
          exit 1

  # 汇总结果
  sync-summary:
    name: Sync Summary（同步汇总）
    if: github.event_name == 'release' && always()  # 即使有失败也执行
    needs: [create-gitee-release, sync-to-gitee]
    runs-on: ubuntu-latest

    steps:
      - name: Summary（汇总）
        run: |
          echo "📊 Gitee Release 同步完成！"
          echo "📍 Release URL: https://gitee.com/lakernote/easy-postman/releases/${{ needs.create-gitee-release.outputs.tag_name }}"
          echo ""
          echo "已同步到 Gitee 的平台："
          echo "  🪟 Windows MSI"
          echo "  🍎 macOS Apple Silicon (ARM64)"
          echo ""
          echo "💡 其他平台（Windows Portable、macOS Intel、Ubuntu DEB）仅在 GitHub Release 提供"
          echo ""
          if [ "${{ needs.sync-to-gitee.result }}" == "success" ]; then
            echo "✅ 所有配置平台均已成功上传到 Gitee！"
          else
            echo "⚠️ 部分平台上传可能失败，请检查上方日志"
          fi

