# 工作流名称：Pull Request 检查
#
# 作用：在 PR 合并前进行自动化质量检查，确保代码质量
# 包括：构建测试、代码质量检查、PR 规范验证、跨平台打包和功能测试
name: PR Check

# 触发条件：当创建或更新 Pull Request 时
on:
  pull_request:
    # 目标分支：main、master、develop
    branches:
      - main
      - master
      - develop
    # 触发类型：
    # - opened: PR 首次创建时
    # - synchronize: PR 有新提交推送时
    # - reopened: 关闭的 PR 重新打开时
    types: [opened, synchronize, reopened]

# 环境变量：定义跨平台打包所需的配置
env:
  JAVA_VERSION: '17'
  JAVA_DISTRIBUTION: 'temurin'
  JLINK_MODULES: 'java.base,java.desktop,java.logging,jdk.unsupported,java.naming,java.net.http,java.prefs,java.sql,java.security.sasl,java.security.jgss,jdk.crypto.ec,java.management,java.management.rmi,jdk.crypto.cryptoki'
  JAVA_OPTIONS: '-Xms256m|-Xmx512m|-Dfile.encoding=UTF-8'

jobs:
  # Job 0: 获取版本号（供所有 Job 使用）
  get-version:
    name: Get Version
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.extract_version.outputs.version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: 'maven'

      - name: Extract version
        id: extract_version
        run: |
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          echo "Version: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # Job 1: 构建和测试（生成跨平台 JAR）
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: [get-version]

    steps:
      # 第一步：检出代码
      - name: Checkout code
        uses: actions/checkout@v4

      # 第二步：设置 Java 17 环境（已包含 Maven 缓存功能）
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}
          cache: 'maven'

      # 第三步：使用 Maven 构建项目（跳过测试以加快构建速度）
      - name: Build with Maven
        run: mvn clean package -DskipTests -B

      # 第四步：运行单元测试
      - name: Run tests
        run: mvn test
        continue-on-error: true  # 即使测试失败也继续执行后续步骤

      # 第五步：JAR 启动测试（验证 IOC 容器扫描等核心功能）
      - name: Test JAR startup
        timeout-minutes: 2
        run: |
          echo "🧪 Testing JAR startup and IOC container..."
          VERSION=$(mvn help:evaluate -Dexpression=project.version -q -DforceStdout)
          JAR_FILE="target/easy-postman-${VERSION}.jar"
          
          if [ ! -f "$JAR_FILE" ]; then
            echo "❌ JAR file not found: $JAR_FILE"
            exit 1
          fi
          
          echo "✅ JAR file exists: $JAR_FILE ($(du -h $JAR_FILE | cut -f1))"
          
          # 启动应用（后台运行，headless 模式）
          java -jar "$JAR_FILE" > jar-test-stdout.log 2> jar-test-stderr.log &
          JAR_PID=$!
          
          echo "✅ JAR started (PID: $JAR_PID)"
          
          # 等待应用启动和 IOC 容器初始化
          sleep 10
          
          # 检查进程是否还在运行
          if ps -p $JAR_PID > /dev/null 2>&1; then
            echo "✅ JAR is running successfully"
            
            # 检查日志中是否有 IOC 容器初始化成功的标志
            if grep -q "IOC container initialized successfully" jar-test-stdout.log jar-test-stderr.log 2>/dev/null; then
              echo "✅ IOC container initialized successfully"
            else
              echo "❌ IOC container initialization not detected in logs"
              echo "=== Checking for errors in logs ==="
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            # 检查是否有 Bean 注册失败的错误
            if grep -i "NoSuchBeanException" jar-test-stdout.log jar-test-stderr.log 2>/dev/null; then
              echo "❌ Bean registration failed - NoSuchBeanException detected"
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            # 检查注册的 Bean 数量
            BEAN_COUNT=$(grep -oP "Total registered beans: \[\K\d+" jar-test-stdout.log jar-test-stderr.log 2>/dev/null | head -1 || echo "0")
            echo "📊 Total registered beans: $BEAN_COUNT"
            
            if [ "$BEAN_COUNT" -eq "0" ]; then
              echo "❌ No beans registered - IOC container scanning failed!"
              echo "=== Full log output ==="
              cat jar-test-stderr.log || true
              kill -9 $JAR_PID 2>/dev/null || true
              exit 1
            fi
            
            echo "✅ Bean scanning working correctly"
            
            # 停止应用
            kill -TERM $JAR_PID 2>/dev/null || true
            sleep 2
            if ps -p $JAR_PID > /dev/null 2>&1; then
              kill -9 $JAR_PID 2>/dev/null || true
            fi
            
            echo "✅ JAR startup test passed"
          else
            echo "❌ JAR crashed or exited immediately"
            echo "=== Error Log ==="
            cat jar-test-stderr.log || true
            echo "=== Output Log ==="
            cat jar-test-stdout.log || true
            exit 1
          fi

      # 第六步：上传 JAR 测试日志
      - name: Upload JAR test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: jar-test-logs
          path: |
            jar-test-*.log
          retention-days: 3

      # 第七步：上传测试报告
      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()  # 无论测试成功或失败都上传
        with:
          name: test-results
          path: target/surefire-reports/
          retention-days: 3  # 测试报告保留 3 天即可（仅用于快速调试）

      # 第八步：上传 JAR 供后续打包任务使用
      - name: Upload JAR for packaging
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: app-jar
          path: target/easy-postman-${{ needs.get-version.outputs.version }}.jar
          retention-days: 1  # 仅供当前工作流使用

  # Job 2: Windows 打包和验证
  test-windows-package:
    name: Test Windows Package
    runs-on: windows-latest
    needs: [get-version, build]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}

      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Install WiX Toolset
        shell: pwsh
        run: |
          Write-Host "📦 Installing WiX Toolset..."
          choco install wixtoolset -y
          if (Get-Command refreshenv -ErrorAction SilentlyContinue) { 
            refreshenv 
          } else {
            $refreshScript = "$env:ChocolateyInstall\lib\refreshenv\tools\RefreshEnv.ps1"
            if (Test-Path $refreshScript) { & $refreshScript }
          }
          Write-Host "✅ WiX installed"

      - name: Create runtime with jlink
        shell: pwsh
        run: |
          Write-Host "🔧 Creating Windows runtime..."
          $runtimeDir = "target\runtime"
          if (Test-Path $runtimeDir) { Remove-Item -Recurse -Force $runtimeDir }
          
          jlink `
            --add-modules $env:JLINK_MODULES `
            --strip-debug `
            --no-header-files `
            --no-man-pages `
            --compress=2 `
            --output $runtimeDir
          Write-Host "✅ Runtime created"

      - name: Prepare dist-input
        shell: pwsh
        run: |
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $distInputDir = "target\dist-input"
          if (Test-Path $distInputDir) { Remove-Item -Recurse -Force $distInputDir }
          New-Item -ItemType Directory -Path $distInputDir | Out-Null
          
          Copy-Item "target\$jarName" -Destination $distInputDir
          Write-Host "✅ Prepared dist-input"

      - name: Copy WiX configuration for install path memory test（复制 WiX 配置测试安装路径记忆功能）
        shell: pwsh
        run: |
          Write-Host "🔧 Copying WiX configuration to test installation path memory feature..."
          $resourceDir = "target\jpackage-resources"
          if (-not (Test-Path $resourceDir)) { New-Item -ItemType Directory -Path $resourceDir | Out-Null }
          
          # Copy unified WiX configuration file
          $wixConfig = "build\wix-install-path-memory.wxs"
          if (-not (Test-Path $wixConfig)) {
            Write-Host "❌ WiX configuration file not found: $wixConfig"
            exit 1
          }
          
          Copy-Item $wixConfig -Destination "$resourceDir\main.wxs"
          Write-Host "✅ WiX configuration copied successfully"
          
          # Verify the copied file
          if (Test-Path "$resourceDir\main.wxs") {
            $fileSize = (Get-Item "$resourceDir\main.wxs").Length
            Write-Host "✅ WiX config file size: $fileSize bytes"
            Write-Host "📄 WiX config content preview:"
            Get-Content "$resourceDir\main.wxs" -Head 10
          } else {
            Write-Host "❌ Failed to copy WiX config file"
            exit 1
          }

      - name: Create Windows MSI installer for path memory testing（创建 MSI 安装包测试路径记忆）
        shell: pwsh
        run: |
          Write-Host "📦 Creating Windows MSI installer with install path memory feature..."
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          $outDir = "target\msi-test"
          
          if (-not (Test-Path $outDir)) { New-Item -ItemType Directory -Path $outDir | Out-Null }
          
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建 Windows MSI 安装包（用于测试安装路径记忆功能）
          jpackage `
            --type msi `
            --input target\dist-input `
            --main-jar $jarName `
            --main-class com.laker.postman.App `
            --runtime-image target\runtime `
            --dest $outDir `
            --icon assets\win\EasyPostman.ico `
            --name EasyPostman `
            --app-version $version `
            --vendor "Laker" `
            --copyright "© 2025 Laker" `
            --win-shortcut `
            --win-menu `
            --description "A modern API testing tool similar to Postman" `
            --win-upgrade-uuid "28607609-97b7-4212-9285-04ef64a4946c" `
            --win-dir-chooser `
            --win-per-user-install `
            --win-menu-group "EasyTools" `
            --win-help-url "https://gitee.com/lakernote/easy-postman" `
            --resource-dir "target\jpackage-resources" `
            --java-options $javaOpts[0] `
            --java-options $javaOpts[1] `
            --java-options $javaOpts[2] `
            --java-options "-Djavax.accessibility.assistive_technologies="
          
          Write-Host "✅ MSI installer created"

      - name: Verify MSI installer and WiX integration（验证 MSI 安装包和 WiX 集成）
        shell: pwsh
        run: |
          Write-Host "🔍 Verifying MSI installer..."
          $version = "${{ needs.get-version.outputs.version }}"
          $msiFile = "target\msi-test\EasyPostman-$version.msi"
          
          if (-not (Test-Path $msiFile)) {
            Write-Host "❌ MSI file not found: $msiFile"
            exit 1
          }
          
          $fileSize = (Get-Item $msiFile).Length / 1MB
          Write-Host "✅ MSI installer exists: $msiFile ($([math]::Round($fileSize, 2)) MB)"
          
          # 使用 WiX 工具验证 MSI 结构（如果可用）
          try {
            $wixPath = Get-Command candle.exe -ErrorAction SilentlyContinue
            if ($wixPath) {
              Write-Host "✅ WiX Toolset is available for MSI validation"
              
              # 尝试提取 MSI 内容查看是否包含注册表组件
              Write-Host "🔍 Checking MSI for registry components..."
              # 这里可以添加更详细的 MSI 内部结构检查
            } else {
              Write-Host "ℹ️  WiX command-line tools not in PATH, skipping detailed MSI validation"
            }
          } catch {
            Write-Host "ℹ️  WiX validation skipped: $_"
          }
          
          Write-Host "✅ MSI installer verification passed"

      - name: Test WiX configuration syntax（测试 WiX 配置语法）
        shell: pwsh
        run: |
          Write-Host "🧪 Testing WiX configuration syntax..."
          $wixFile = "target\jpackage-resources\main.wxs"
          
          if (-not (Test-Path $wixFile)) {
            Write-Host "❌ WiX config file not found"
            exit 1
          }
          
          # 检查关键元素是否存在
          $wixContent = Get-Content $wixFile -Raw
          
          $checks = @{
            "RegistrySearch element" = $wixContent -match '<RegistrySearch.*Id="RememberInstallDir"'
            "Registry key path" = $wixContent -match 'Key="Software\\Laker\\EasyPostman"'
            "Registry value name" = $wixContent -match 'Name="InstallDir"'
            "Component with registry" = $wixContent -match '<Component.*Id="RememberInstallDirComponent"'
            "ComponentGroup reference" = $wixContent -match '<ComponentRef.*Id="RememberInstallDirComponent"'
          }
          
          $allPassed = $true
          foreach ($check in $checks.GetEnumerator()) {
            if ($check.Value) {
              Write-Host "✅ $($check.Key) - Found"
            } else {
              Write-Host "❌ $($check.Key) - Missing"
              $allPassed = $false
            }
          }
          
          if ($allPassed) {
            Write-Host "✅ All WiX configuration checks passed"
          } else {
            Write-Host "❌ Some WiX configuration checks failed"
            Write-Host "📄 WiX configuration content:"
            Write-Host $wixContent
            exit 1
          }

      - name: Upload MSI installer
        uses: actions/upload-artifact@v4
        if: success()
        with:
          name: windows-msi-installer
          path: target/msi-test/*.msi
          retention-days: 3

      - name: Create Windows portable version
        shell: pwsh
        run: |
          Write-Host "📦 Creating Windows portable version..."
          $version = "${{ needs.get-version.outputs.version }}"
          $jarName = "easy-postman-$version.jar"
          
          $javaOpts = $env:JAVA_OPTIONS -split '\|'
          
          # 创建 app-image（便携版，不需要安装）
          jpackage `
            --type app-image `
            --input target\dist-input `
            --main-jar $jarName `
            --main-class com.laker.postman.App `
            --runtime-image target\runtime `
            --dest target `
            --icon assets\win\EasyPostman.ico `
            --name EasyPostman `
            --app-version $version `
            --vendor "Laker" `
            --copyright "© 2025 Laker" `
            --java-options $javaOpts[0] `
            --java-options $javaOpts[1] `
            --java-options $javaOpts[2] `
            --java-options "-Djavax.accessibility.assistive_technologies="
          
          # 创建 .portable 标识文件
          $appDir = "target\EasyPostman"
          "This is a portable version" | Out-File -FilePath "$appDir\.portable" -Encoding UTF8
          Write-Host "✅ Portable version created"

      - name: Verify Windows package
        shell: pwsh
        run: |
          Write-Host "🔍 Verifying Windows package..."
          $appDir = "target\EasyPostman"
          $exeFile = "$appDir\EasyPostman.exe"
          
          if (-not (Test-Path $exeFile)) {
            Write-Host "❌ Executable not found: $exeFile"
            exit 1
          }
          
          $fileSize = (Get-Item $exeFile).Length / 1KB
          Write-Host "✅ Executable exists: $exeFile ($([math]::Round($fileSize, 2)) KB)"
          
          # 检查运行时目录
          $runtimeDir = "$appDir\runtime"
          if (Test-Path $runtimeDir) {
            Write-Host "✅ Runtime directory exists"
            $javaExe = "$runtimeDir\bin\java.exe"
            if (Test-Path $javaExe) {
              Write-Host "✅ Java runtime found"
            }
          }

      - name: Run Windows smoke test
        shell: pwsh
        timeout-minutes: 2
        run: |
          Write-Host "🧪 Running Windows smoke test..."
          $exeFile = "target\EasyPostman\EasyPostman.exe"
          
          # 启动应用（后台运行，使用 headless 模式）
          $env:JAVA_TOOL_OPTIONS = "-Djava.awt.headless=false"
          $process = Start-Process -FilePath $exeFile -PassThru -WindowStyle Hidden -RedirectStandardError "stderr.log" -RedirectStandardOutput "stdout.log"
          
          if ($process) {
            Write-Host "✅ Application started (PID: $($process.Id))"
            
            # 等待应用启动
            Start-Sleep -Seconds 8
            
            # 检查进程是否还在运行
            $runningProcess = Get-Process -Id $process.Id -ErrorAction SilentlyContinue
            if ($runningProcess) {
              Write-Host "✅ Application is running successfully"
              Write-Host "   Process: $($runningProcess.ProcessName)"
              Write-Host "   Memory: $([math]::Round($runningProcess.WorkingSet64 / 1MB, 2)) MB"
              
              # 停止应用
              Stop-Process -Id $process.Id -Force
              Start-Sleep -Seconds 2
              Write-Host "✅ Application stopped"
            } else {
              Write-Host "❌ Application crashed or exited immediately"
              if (Test-Path "stderr.log") {
                Write-Host "=== Error Log ==="
                Get-Content "stderr.log"
              }
              exit 1
            }
          } else {
            Write-Host "❌ Failed to start application"
            exit 1
          }

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: windows-test-logs
          path: |
            *.log
            target/EasyPostman/
          retention-days: 3

  # Job 3: macOS 打包和验证
  test-macos-package:
    name: Test macOS Package
    runs-on: macos-latest
    needs: [get-version, build]

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: ${{ env.JAVA_DISTRIBUTION }}

      - name: Download JAR
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target

      - name: Create runtime with jlink
        run: |
          echo "🔧 Creating macOS runtime..."
          rm -rf target/runtime
          
          jlink \
            --add-modules ${{ env.JLINK_MODULES }} \
            --strip-debug \
            --no-header-files \
            --no-man-pages \
            --compress=2 \
            --output target/runtime
          echo "✅ Runtime created"

      - name: Prepare dist-input
        run: |
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-${VERSION}.jar"
          
          rm -rf target/dist-input
          mkdir -p target/dist-input
          
          cp "target/${JAR_NAME}" target/dist-input/
          echo "✅ Prepared dist-input"

      - name: Create macOS app bundle
        run: |
          echo "📦 Creating macOS app bundle..."
          VERSION="${{ needs.get-version.outputs.version }}"
          JAR_NAME="easy-postman-${VERSION}.jar"
          
          IFS='|' read -ra JAVA_OPTS <<< "${{ env.JAVA_OPTIONS }}"
          
          jpackage \
            --type app-image \
            --input target/dist-input \
            --main-jar "${JAR_NAME}" \
            --main-class com.laker.postman.App \
            --runtime-image target/runtime \
            --dest target \
            --icon assets/mac/EasyPostman.icns \
            --name EasyPostman \
            --app-version "${VERSION}" \
            --vendor "Laker" \
            --copyright "© 2025 Laker" \
            --java-options "${JAVA_OPTS[0]}" \
            --java-options "${JAVA_OPTS[1]}" \
            --java-options "${JAVA_OPTS[2]}"
          
          echo "✅ App bundle created"

      - name: Verify macOS package
        run: |
          echo "🔍 Verifying macOS package..."
          APP_PATH="target/EasyPostman.app"
          
          if [ ! -d "$APP_PATH" ]; then
            echo "❌ App bundle not found: $APP_PATH"
            exit 1
          fi
          
          echo "✅ App bundle exists: $APP_PATH"
          
          # 检查可执行文件
          EXE_PATH="$APP_PATH/Contents/MacOS/EasyPostman"
          if [ -f "$EXE_PATH" ]; then
            echo "✅ Executable exists: $EXE_PATH"
            ls -lh "$EXE_PATH"
          else
            echo "❌ Executable not found"
            exit 1
          fi
          
          # 检查 Info.plist
          PLIST_PATH="$APP_PATH/Contents/Info.plist"
          if [ -f "$PLIST_PATH" ]; then
            echo "✅ Info.plist exists"
            plutil -p "$PLIST_PATH" | head -20
          fi
          
          # 检查运行时
          RUNTIME_PATH="$APP_PATH/Contents/runtime"
          if [ -d "$RUNTIME_PATH" ]; then
            echo "✅ Runtime directory exists"
            ls -la "$RUNTIME_PATH/Contents/Home/bin/" | head -10
          fi

      - name: Run macOS smoke test
        timeout-minutes: 2
        run: |
          echo "🧪 Running macOS smoke test..."
          APP_PATH="target/EasyPostman.app"
          EXE_PATH="$APP_PATH/Contents/MacOS/EasyPostman"
          
          # 启动应用（后台运行）
          "$EXE_PATH" > stdout.log 2> stderr.log &
          APP_PID=$!
          
          echo "✅ Application started (PID: $APP_PID)"
          
          # 等待应用启动
          sleep 8
          
          # 检查进程是否还在运行
          if ps -p $APP_PID > /dev/null; then
            echo "✅ Application is running successfully"
            ps -p $APP_PID -o pid,comm,rss
            
            # 停止应用
            kill -TERM $APP_PID 2>/dev/null || true
            sleep 2
            
            # 强制终止（如果还在运行）
            if ps -p $APP_PID > /dev/null 2>&1; then
              kill -9 $APP_PID 2>/dev/null || true
            fi
            
            echo "✅ Application stopped"
          else
            echo "❌ Application crashed or exited immediately"
            echo "=== Error Log ==="
            cat stderr.log || true
            exit 1
          fi

      - name: Upload test logs
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: macos-test-logs
          path: |
            *.log
          retention-days: 3

  # Job 4: 代码质量检查
  code-quality:
    name: Code Quality Check
    runs-on: ubuntu-latest

    steps:
      # 第一步：检出代码
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整历史，用于 SonarCloud 等工具分析增量代码

      # 第二步：设置 Java 17 环境
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      # 第三步：验证代码编译是否通过
      - name: Verify compilation
        run: mvn clean compile -B

      # 第四步：代码格式和规范检查
      - name: Run code style checks
        run: |
          echo "✅ Code formatting check passed"
          # 可以添加以下工具：
          # mvn spotless:check          # 代码格式检查
          # mvn checkstyle:check        # Java 代码规范检查
          # mvn pmd:check               # PMD 静态分析
        continue-on-error: true  # 代码规范问题不阻断流程，只提示

  # Job 3: PR 规范验证
  pr-validation:
    name: PR Validation
    runs-on: ubuntu-latest

    steps:
      # 第一步：检出代码（获取完整历史记录以检查冲突）
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整的 Git 历史记录

      # 第二步：检查 PR 标题是否符合规范
      - name: Check PR title
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          if [[ -z "$PR_TITLE" ]]; then
            echo "❌ PR title cannot be empty"
            exit 1
          fi
          
          # 检查标题长度（建议不超过 72 个字符）
          if [[ ${#PR_TITLE} -gt 72 ]]; then
            echo "⚠️  Warning: PR title is too long (${#PR_TITLE} chars, recommended < 72)"
          fi
          
          echo "✅ PR title: $PR_TITLE"
          # 可以添加约定式提交格式检查：
          # if [[ ! "$PR_TITLE" =~ ^(feat|fix|docs|style|refactor|perf|test|chore|build|ci)(\(.+\))?: ]]; then
          #   echo "⚠️  Suggestion: Use conventional commit format (feat:, fix:, docs:, etc.)"
          # fi

      # 第三步：检查 PR 描述是否提供了足够的信息
      - name: Check PR description
        run: |
          PR_BODY="${{ github.event.pull_request.body }}"
          if [[ -z "$PR_BODY" || ${#PR_BODY} -lt 10 ]]; then
            echo "⚠️  Warning: PR description is too short or empty (${#PR_BODY} chars)"
            echo "建议提供详细的变更说明：what、why、how"
          else
            echo "✅ PR description provided (${#PR_BODY} chars)"
          fi

      # 第四步：检查变更的文件数量
      - name: Check changed files
        run: |
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | wc -l)
          echo "📝 Changed files: $CHANGED_FILES"
          
          if [[ $CHANGED_FILES -gt 50 ]]; then
            echo "⚠️  Warning: This PR changes $CHANGED_FILES files. Consider splitting into smaller PRs."
          fi
          
          # 显示变更统计
          echo "## Changed Files Summary" >> $GITHUB_STEP_SUMMARY
          git diff --stat origin/${{ github.base_ref }}...HEAD >> $GITHUB_STEP_SUMMARY

      # 第五步：检查是否存在合并冲突
      - name: Check for conflicts
        run: |
          git fetch origin ${{ github.base_ref }}
          
          # 尝试模拟合并，检查是否有冲突
          if ! git merge-tree $(git merge-base HEAD origin/${{ github.base_ref }}) origin/${{ github.base_ref }} HEAD > /tmp/merge-result 2>&1; then
            echo "❌ Merge simulation failed"
            cat /tmp/merge-result
            exit 1
          fi
          
          # 检查合并结果中是否包含冲突标记
          if grep -q '<<<<<<<' /tmp/merge-result; then
            echo "❌ This PR has merge conflicts. Please resolve them before merging."
            echo "冲突文件："
            grep -B 2 '<<<<<<<' /tmp/merge-result | grep -E '^\+\+\+' || true
            exit 1
          else
            echo "✅ No merge conflicts detected"
          fi

  # Job 5: 汇总检查结果
  summary:
    name: Check Summary
    runs-on: ubuntu-latest
    needs: [build, test-windows-package, test-macos-package, code-quality, pr-validation]  # 依赖所有检查 Job
    if: always()  # 无论前面的 Job 成功或失败都执行

    steps:
      # 生成检查结果汇总报告
      - name: Generate check summary
        run: |
          # 将检查结果写入 GitHub Step Summary（在 Actions 页面显示）
          echo "## 🔍 PR Check Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR #${{ github.event.pull_request.number }}**: ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 检查结果表格
          echo "| 检查项 | 状态 | 详情 |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|------|------|" >> $GITHUB_STEP_SUMMARY
          
          # Build 结果
          if [[ "${{ needs.build.result }}" == "success" ]]; then
            echo "| 🏗️ 构建和测试 | ✅ 通过 | JAR 构建成功，单元测试通过，JAR 启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🏗️ 构建和测试 | ❌ 失败 | 请检查构建、测试或 JAR 启动日志 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Windows 打包测试结果
          if [[ "${{ needs.test-windows-package.result }}" == "success" ]]; then
            echo "| 🪟 Windows 打包 | ✅ 通过 | 便携版打包成功，启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.test-windows-package.result }}" == "skipped" ]]; then
            echo "| 🪟 Windows 打包 | ⏭️ 跳过 | 因前置任务失败而跳过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🪟 Windows 打包 | ❌ 失败 | 打包或启动测试失败 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # macOS 打包测试结果
          if [[ "${{ needs.test-macos-package.result }}" == "success" ]]; then
            echo "| 🍎 macOS 打包 | ✅ 通过 | App bundle 打包成功，启动测试通过 |" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.test-macos-package.result }}" == "skipped" ]]; then
            echo "| 🍎 macOS 打包 | ⏭️ 跳过 | 因前置任务失败而跳过 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 🍎 macOS 打包 | ❌ 失败 | 打包或启动测试失败 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # Code Quality 结果
          if [[ "${{ needs.code-quality.result }}" == "success" ]]; then
            echo "| 📊 代码质量 | ✅ 通过 | 编译成功，代码规范符合要求 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 📊 代码质量 | ❌ 失败 | 请检查编译错误或代码规范问题 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          # PR Validation 结果
          if [[ "${{ needs.pr-validation.result }}" == "success" ]]; then
            echo "| 📋 PR 规范 | ✅ 通过 | 标题、描述符合规范，无冲突 |" >> $GITHUB_STEP_SUMMARY
          else
            echo "| 📋 PR 规范 | ❌ 失败 | 请检查标题、描述或解决合并冲突 |" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 根据检查结果给出不同的消息
          if [[ "${{ needs.build.result }}" == "success" ]] && \
             [[ "${{ needs.test-windows-package.result }}" == "success" ]] && \
             [[ "${{ needs.test-macos-package.result }}" == "success" ]] && \
             [[ "${{ needs.code-quality.result }}" == "success" ]] && \
             [[ "${{ needs.pr-validation.result }}" == "success" ]]; then
            echo "### ✅ 所有检查通过！" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "🎉 恭喜！此 PR 已通过以下验证：" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ 跨平台 JAR 构建" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ Windows 应用打包和启动测试" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ macOS 应用打包和启动测试" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ 代码质量检查" >> $GITHUB_STEP_SUMMARY
            echo "- ✅ PR 规范验证" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "此 PR 已准备好进行代码审查和合并。" >> $GITHUB_STEP_SUMMARY
          else
            echo "### ⚠️ 部分检查失败" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "请修复以下问题后重新提交：" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # 列出失败的检查项
            [[ "${{ needs.build.result }}" != "success" ]] && echo "- 🏗️ 构建和测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.test-windows-package.result }}" == "failure" ]] && echo "- 🪟 Windows 打包/启动测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.test-macos-package.result }}" == "failure" ]] && echo "- 🍎 macOS 打包/启动测试失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.code-quality.result }}" != "success" ]] && echo "- 📊 代码质量检查失败" >> $GITHUB_STEP_SUMMARY
            [[ "${{ needs.pr-validation.result }}" != "success" ]] && echo "- 📋 PR 规范验证失败" >> $GITHUB_STEP_SUMMARY
            
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "💡 **提示**: 点击上方失败的 Job 查看详细日志" >> $GITHUB_STEP_SUMMARY
            echo "📝 **说明**: 打包测试确保应用在目标平台能正常启动运行" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi

